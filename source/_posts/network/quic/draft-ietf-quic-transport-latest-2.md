---
title: QUIC协议翻译 - draft-ietf-quic-transport-latest Part 2.
date: 2019-02-14 13:34:06
tags:
  - QUIC
  - translate
  - RFC
  - Protocol
---

本文是对QUIC协议IETF提案：[draft-ietf-quic-transport-latest](https://quicwg.org/base-drafts/draft-ietf-quic-transport.html)翻译的第二部分。

[draft-ietf-quic-transport-latest](https://quicwg.org/base-drafts/draft-ietf-quic-transport.html)是在[draft-ietf-quic-invariants-latest](https://quicwg.org/base-drafts/draft-ietf-quic-invariants.html)基础上定义的第一个版本的QUIC协议，这里描述了QUIC协议的核心，包括一些概念定义与具体的协议行为。

第二部分翻译内容包括第4，5节。内容包括流量控制与连接等概念。

<!-- more -->

### 4. 流量控制

为了防止发送方的速度过快从而导致接收者难以接受数据，或防止恶意发送方在接收方处消耗大量内存，有必要限制接收方可以缓冲的数据量，为了使接收方能够限制对连接的内存，并对发送方实施调控，流被单独地和作为聚合流控制。QUIC接收方控制发送方可以在流上发送的最大数据量，如第4.1节和第4.2节所述。

同样，为了限制连接中的并发性，QUIC端点控制其对等方可以启动的最大累积流数，如第4.5节所述。

在CRYPTO帧中发送的数据的流控制方式与流数据的流控制方式不同。 QUIC依赖于加密协议实现来避免过度缓冲数据，请参阅[QUIC-TLS]。具体的实现中应该为QUIC提供一个接口来告诉QUIC它的缓冲限制，以便在限制不同层次上过多的缓冲。

#### 4.1 数据流量控制

QUIC采用类似于HTTP/2 [HTTP2]中基于信用分数（credit）的流控制方案，其中接收方通告它准备在给定流和整个连接上接收的字节数。这产生了QUIC中的两级数据流控制：

- 流级流量控制，通过限制可在任何流上发送的数据量，防止单个流消耗连接的整个接收缓冲区。
- 连接级流量控制，通过限制所有流上STREAM帧中发送的流数据的总字节数，防止发送者超过接收者的连接缓冲容量。

接收方通过在握手期间发送传输参数来设置所有流的初始信用分数（credit）（第7.3节）。接收方向发送方发送MAX_STREAM_DATA（第19.10节）或MAX_DATA（第19.9节）帧，以通告增加的信用分数（credit）。

接收方通过发送MAX_STREAM_DATA帧并适当地设置流ID字段来通告流的信用分数（credit）。MAX_STREAM_DATA帧指示流的最大绝对字节偏移量。接收方可以使用当前消耗的数据偏移量来确定被通告的流量控制偏移量。接收方可以在多个数据包中发送MAX_STREAM_DATA帧，即使其中一个数据包丢失了，也可以确保发送方在消耗完流控制信用分数（credit）之前收到更新。

接收方通过发送MAX_DATA帧来通告连接信用分数（credit），该帧指示所有流的绝对字节偏移之和的最大值。接收方维护在所有流上接收的累积字节总和，用于检查流控制违规。接收方可以使用所有流上消耗的字节总数来确定要通告的最大数据限制。

接收方可以通过在连接期间的任何时间发送MAX_STREAM_DATA或MAX_DATA帧来通告更大的偏移。但是接收方不能背弃通告的值。也就是说，一旦接收方通告了一个偏移量，它再通告对方一个较小的偏移量则不会产生效果。

如果发送方违反被通告的连接或流数据量限制，接收方必须用FLOW_CONTROL_ERROR错误（第11节）关闭连接。

发送方必须忽略任何不提升流量控制限制的MAX_STREAM_DATA或MAX_DATA帧。

如果发送方用完了流量控制信用分数，它将无法发送新数据并被视为已被阻塞。发送方应该发送TREAM_DATA_BLOCKED或DATA_BLOCKED帧以指示它有要写入的数据但被流控制限制阻止。预计这些帧在常见情况下不经常发送，但它们被认为对调试和监视有用。

发送方在达到数据限制时应该仅发送一次STREAM_DATA_BLOCKED或DATA_BLOCKED帧。除非确定原始帧丢失，否则发送方不应为相同的数据限制发送多个STREAM_DATA_BLOCKED或DATA_BLOCKED帧。在数据限制增加后，可以发送另一个STREAM_DATA_BLOCKED或DATA_BLOCKED帧。

#### 4.2 流量控制信用分数的增加

本文档将MAX_STREAM_DATA或MAX_DATA帧中通告的时间间隔和字节数量限制留给实现，但提供了一些注意事项。这些帧有助于降低连接开销。因此，经常发送具有小变化的帧是不被鼓励的。同时，如果更新频率较低，则需要更大的增量限制以避免阻塞，因此接收方需要提供更大的缓存资源。因此，在确定通告限制的大小时，*在资源维护和开销之间存在折衷。（原文：Thus there is a trade-off between resource commitment and overhead when determining how large a limit is advertised.）*

接收方可以使用基于往返时间估计和接收应用消耗数据的速率的自动调整机制来调整通告增加的信用分数的频率和数量，类似于常见的TCP实现。作为优化，仅当存在要发送的其他帧或者对等体被阻止时发送与流控制相关的帧确保流控制不会导致额外的数据包被发送。

如果发送方用完了流量控制信用分数，它将无法发送新数据并被视为已被阻塞。通常认为最好不要让发送方被阻塞。为避免阻塞发送方，并合理地考虑丢失的可能性，接收方应至少两次往返发送MAX_DATA或MAX_STREAM_DATA帧，然后才能阻塞发送方。

在发送MAX_STREAM_DATA或MAX_DATA之前，接收方不能等待来自发送方的STREAM_DATA_BLOCKED或DATA_BLOCKED帧，因为这样做意味着发送方将至少在整个往返过程中被阻塞，如果对等方选择不发送STREAM_DATA_BLOCKED或DATA_BLOCKED，则被阻塞时间可能更长。

#### 4.3 处理流取消

端点需要最终就消耗的流量控制信用分数达成一致，以避免超出流量控制限制或死锁。

在接收到RESET_STREAM帧时，端点将取消对应流的状态计算并忽略到达该流的其他数据。如果RESET_STREAM帧与同一流的流数据重新排序，则接收者对该流上接收的字节数的估计可能低于发送者对发送的数量的估计。因此，两个端点可能无法就计入连接级流量控制的字节数达成一致。

要解决此问题，RESET_STREAM帧（第19.4节）包括在流上发送的最终数据大小。在接收到RESET_STREAM帧时，接收方明确地知道在RESET_STREAM帧之前在该流上发送了多少字节，并且接收方必须使用流的最终大小来实施连接级流量控制。

RESET_STREAM会终止流的一个方向。对于双向流，RESET_STREAM对相反方向的数据流没有影响。两个端点必须在未终止方向上继续保持流的流控制状态，直到该方向进入终结状态，或者直到其中一个端点发送CONNECTION_CLOSE。

#### 4.4 流最终大小

最终大小是流消耗的流量控制信用分数。假设流上的每个连续字节都发送一次，最终大小是发送的字节数。更一般地说，这比流上发送的最大字节偏移大一。

对于重置的流，最终大小在RESET_STREAM帧中显式携带。否则，最终大小是偏移加上标有FIN标志的STREAM帧的长度，或者在传入的单向流的情况下为0。

当流的接收部分进入“Size Known”或“Reset Recvd”状态时（第3节），端点将知道流的最终大小。

端点不得在最终大小或超出最终大小的流上发送数据。

一旦知道了流的最终大小，它就不能再改变。如果收到RESET_STREAM或STREAM帧，指示流的最终大小发生了变化，则端点应该响应FINAL_SIZE_ERROR错误（参见第11节）。接收方应该将最终大小或超出最终大小的数据接收视为FINAL_SIZE_ERROR错误，即使在流关闭后也是如此。生成这些错误不是强制性的，只是因为要求端点生成这些错误也意味着端点需要维持关闭流的最终大小状态，这可能意味着需要维护一些状态。

#### 4.5 控制并发

端点限制对等方可以打开的传入流的总数。只有流ID小于`max_stream * 4 + initial_stream_id_for_type`的流可以被打开。初始限制在传输参数中设置（参见第18.1节），随后使用MAX_STREAMS帧（第19.11节）公布限制。单向和双向流适用于不同的限制。

端点不得超过其对等端设置的限制。接收流ID超过其发送限制的STREAM帧的端点必须将其视为STREAM_LIMIT_ERROR类型的流错误（第11节）。

接收方不能违背通告。也就是说，一旦接收器使用MAX_STREAMS帧通告流限制，则通告较小的限制无效。接收方必须忽略任何不增加流限制的MAX_STREAMS帧。

与流级和连接级流量控制一样，本文档将通过MAX_STREAMS向对等体通告的时间间隔和流数量留给实现。实现可能会选择增加限制，以保持对等体可用的流数量大致一致。

由于对等端限制而无法打开新流的端点应该发送STREAMS_BLOCKED帧（第19.14节）。该信号被认为对调试很有用。在通告增加信用分数之前，端点不得等待接收此信号，因为这样做意味着对等体将至少在整个往返中被阻塞，并且如果对等体选择不发送STREAMS_BLOCKED帧，则可能持续更长时间。

### 5. 连接

QUIC的连接建立将版本协商与加密和传输握手相结合，以减少连接建立延迟，如第7节所述。一旦建立，连接可以迁移到任一端点的不同IP或端口，如第9节所述。最后，连接可以由任一端点终止，如第10节所述。

#### 5.1 连接ID

每个连接都拥有一组连接标识符或连接ID，每个标识符都可以标识连接。连接ID由端点独立选择;每个端点选择其对等方使用的连接ID。

连接ID的主要功能是确保较低协议层（UDP，IP）的寻址更改不会导致QUIC连接的数据包传递到错误的端点。每个端点使用特定于实现（并且可能是特定于部署）的方法来选择连接ID，该方法将允许具有该连接ID的分组被路由到端点并在接收时由端点识别。

*连接ID不得包含外部观察者可以使用的任何信息，防止将它们与同一连接的其他连接ID相关联。作为一个简单的例子，这意味着在同一连接上不得多次发出相同的连接ID。（原文：Connection IDs MUST NOT contain any information that can be used by an external observer to correlate them with other connection IDs for the same connection.  As a trivial example, this means the same connection ID MUST NOT be issued more than once on the same connection.）*

具有长标头的数据包包括源连接ID和目标连接ID字段。这些字段用于设置新连接的连接ID，有关详细信息，请参阅第7.2节。

具有短标头的数据包（第17.3节）仅包含目标连接ID，并省略显式长度。期望终结点知道目标连接ID字段的长度。使用基于连接ID路由的负载均衡器的端点可以在固定长度上与负载均衡器达成连接ID，或者就编码方案达成一致。固定部分可以编码显式长度，这允许整个连接ID的长度变化并且仍然可以由负载平衡器使用。

版本协商（第17.2.1节）数据包回应客户端选择的连接ID，以确保正确路由到客户端并允许客户端验证数据包是否是初始数据包的响应。

当路由不需要连接ID并且数据包的地址/端口元组足以识别连接时，可以使用零长度连接ID。对等体已选择零长度连接ID的端点必须继续在连接的生存期内使用零长度连接ID，并且绝不能从任何其他本地地址发送数据包。

当端点请求非零长度连接ID时，需要确保对等体具有连接ID可供选择，从中可以选择发送到端点的数据包。这些连接ID由端点使用NEW_CONNECTION_ID帧提供（第19.15节）。

##### 5.1.1 发出连接ID

每个连接ID都有一个关联的序列号，以帮助对消息进行数据去重。在握手期间，端点发出的初始连接ID在长数据包报头的源连接ID字段（第17.2节）中发送。初始连接ID的序列号为0.如果发送preferred_address传输参数，则提供的连接ID的序列号为1。

使用NEW_CONNECTION_ID帧将附加连接ID传送给对等体（第19.15节）。每个新发布的连接ID上的序列号必须增加1.客户端在初始数据包中随机选择的连接ID和重试数据包提供的任何连接ID都不会分配序列号，除非服务端选择将它们保留为初始连接ID。

当端点发出连接ID时，它必须接受在连接期间携带此连接ID的数据包，或者直到其对等体通过RETIRE_CONNECTION_ID帧使连接ID无效（第19.16节）。

端点应该确保其对等体具有足够数量的可用和未使用的连接ID。虽然每个端点独立选择要发出的连接ID数量，但端点应该提供并维护至少八个连接ID。端点应该通过在对等体退出连接ID时或者当端点接收到具有先前未使用的连接ID的数据包时始终提供新的连接ID来执行此操作。启动迁移并要求非零长度连接ID的端点应该在迁移之前为其对等方提供新的连接ID，否则可能会使对等方关闭连接。

##### 5.1.2 使用和退出连接ID

端点可以在连接期间随时将其用于对等的连接ID更改为另一个可用的连接ID。端点使用连接ID的响应来迁移对等体，有关更多信息，请参见第9.5节。

端点维护从其对等方接收的一组连接ID，其中任何一个都可以在发送数据包时使用。当端点希望从使用中删除连接ID时，它会向其对等端发送RETIRE_CONNECTION_ID帧。发送RETIRE_CONNECTION_ID帧表示将不再使用连接ID，并请求对等方使用NEW_CONNECTION_ID帧将其替换为新的连接ID。

如第9.5节所述，每个连接ID必须用于仅从一个本地地址发送的数据包。迁移远离本地地址的端点应该在该地址不再计划使用该地址时退出该地址上使用的所有连接ID。

#### 5.2 将数据包与连接匹配

传入的数据包在被接收时分类。数据包可以与现有连接相关联，或者服务端会创建新连接。

主机尝试将数据包与现有连接相关联。如果数据包具有与现有连接相对应的目标连接ID，则QUIC会相应地处理该数据包。请注意，可以将多个连接ID与连接关联见5.1节。

如果目标连接ID为零长度且数据包与主机不需要连接ID的连接的地址/端口元组匹配，则QUIC将该数据包作为该连接的一部分进行处理。端点应该拒绝使用与现有连接相同的地址的连接尝试，或者使用非零长度的目标连接ID，以便可以将数据包正确地与连接匹配。

端点可以为任何无法与现有连接匹配的数据包发送无状态重置（第10.4节）。无状态重置允许对等方更快地识别连接何时变得不可用。

与现有连接匹配但端点无法去除数据包保护的数据包将被丢弃。

可以丢弃无数据包保护的无效数据包，例如Initial，Retry或Version Negotiation。如果端点在发现错误之前提交状态更改，则必须生成连接错误。

##### 5.2.1 客户端数据包处理

发送到客户端的有效数据包始终包含与客户端选择的值匹配的目标连接ID。选择接收零长度连接ID的客户端可以使用地址/端口元组来标识连接。与现有连接不匹配的数据包将被丢弃。

由于数据包重新排序或丢失，客户端可能会收到使用尚未计算的密钥加密的连接数据包。客户端可以丢弃这些数据包，或者可以缓冲它们以预期以后允许它计算密钥的数据包。

如果客户端收到的数据包具有不受支持的版本，则必须丢弃该数据包。

##### 5.2.2 服务端包处理

如果服务器收到的数据包具有不受支持的版本，但数据包足够大，无法为服务器支持的任何版本启动新连接，则应该按照第6.1节中的说明发送版本协商数据包。服务器可以对这些数据包进行速率控制，以避免版本协商数据包的风暴。

不受支持的版本的第一个数据包可以对任何特定于版本的字段使用不同的语义和编码。特别地，不同的数据包保护密钥可以用于不同的版本。不支持特定版本的服务器不太可能解密数据包的有效负载。服务端不应尝试解码或解密来自未知版本的数据包，而是发送版本协商数据包，前提是数据包足够长。

服务器必须丢弃包含不受支持的版本的其他数据包。

具有受支持版本或无版本字段的数据包与使用连接ID的连接匹配，或者使用（对于具有零长度连接ID的数据包）地址端口元组进行匹配。如果数据包与现有连接不匹配，则服务器继续执行下面的动作。

如果数据包是完全符合规范的初始数据包，则服务器继续进行握手（第7节）。这会将服务端提交到客户端选择的版本。

如果服务器当前没有接受任何新连接，它应该发送一个包含CONNECTION_CLOSE帧的初始数据包，错误代码为SERVER_BUSY。

如果该数据包是0-RTT数据包，则服务端可以缓冲有限数量的这些分组以等待迟到的初始数据包。在服务端响应之前，客户端被禁止发送握手数据包，因此服务器应该忽略任何此类数据包。

服务器必须在所有其他情况下丢弃传入的数据包。

#### 5.3 QUIC连接的生命周期

> TBD









