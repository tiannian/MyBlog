---
title: QUIC协议翻译 - draft-ietf-quic-transport-latest Part 3.（未完成）
date: 2019-02-15 21:41:11
tags:
  - QUIC
  - translate
  - RFC
  - Protocol
---

本文是对QUIC协议IETF提案：[draft-ietf-quic-transport-latest](https://quicwg.org/base-drafts/draft-ietf-quic-transport.html)翻译的第三部分。

[draft-ietf-quic-transport-latest](https://quicwg.org/base-drafts/draft-ietf-quic-transport.html)是在[draft-ietf-quic-invariants-latest](https://quicwg.org/base-drafts/draft-ietf-quic-invariants.html)基础上定义的第一个版本的QUIC协议，这里描述了QUIC协议的核心，包括一些概念定义与具体的协议行为。

第三部分翻译内容包括第6，7，8节。内容包含连接建立，版本协商与如何地域DDoS攻击。

<!-- more -->

### 6. 版本协商

版本协商可确保客户端和服务端同意相互支持的QUIC版本。服务端发送版本协商数据包以响应可能启动新连接的每个数据包，有关详细信息，请参阅第5.2节。

尝试与服务端建立新连接的客户端之间的交换的前几条消息如图3所示。版本协商完成后，可以继续建立连接，例如，如第7.1节所示。

```
Client                                                  Server
Packet (v=X) ->
                        <- Version Negotiation (supported=Y,Z)
Packet (v=Y) ->
                                            <- Packet(s) (v=Y)
```

客户端发送的第一个数据包的大小将决定服务端是否发送版本协商数据包。支持多个QUIC版本的客户端应该将它们发送的第一个数据包填充到它们支持的所有版本中最大的最小数据包大小。这可确保服务端在存在相互支持的版本时进行响应。

#### 6.1 发送版本协商数据包

如果客户端选择的版本对服务端不可接受，则服务端将使用版本协商数据包进行响应（请参阅第17.2.1节）。这包括服务端将接受的版本列表。端点不得使用版本协商数据包来响应版本协商数据包。

此系统允许服务端处理具有不受支持的版本的数据包而不保留状态。虽然响应中发送的初始数据包或版本协商数据包可能会丢失，但客户端将发送新数据包，直到它成功收到响应或放弃连接尝试。

服务端可以限制它发送的版本协商数据包的数量。例如，能够将分组识别为0-RTT的服务端可以选择不发送版本协商分组以响应0-RTT数据包，期望它最终将接收初始数据包。

#### 6.2 处理版本协商数据包

当客户端收到版本协商数据包时，它首先检查目标和源连接ID字段是否与客户端发送的数据包中的源和目标连接ID字段匹配。如果此检查失败，则必须丢弃该数据包。

一旦确定版本协商分组有效，则客户端然后从服务端提供的列表中选择可接受的协议版本。然后，客户端尝试使用该版本创建连接。虽然客户端发送的初始数据包的内容可能不会响应版本协商而改变，但客户端必须增加它在发送的每个数据包上使用的数据包序号。数据包必须继续使用长包头（第17.2节），并且必须包含新的协商协议版本。

客户端必须使用长报头格式并在所有数据包中包含其选定版本，直到它具有1-RTT密钥并且它已从服务端接收到不是版本协商数据包的数据包。

客户端不得更改它使用的版本，除非它是响应来自服务端的版本协商数据包。一旦客户端收到来自服务端的不是版本协商数据包的数据包，它必须丢弃同一连接上的其他版本协商数据包。类似地，如果客户端已经收到并对版本协商数据包执行了操作，则它必须忽略版本协商数据包。

客户端必须忽略列出客户端所选版本的版本协商数据包。如果客户端不支持服务端提供的任何版本，则会中止连接尝试。

客户端可以在收到版本协商数据包后尝试0-RTT。发送附加0-RTT数据包的客户端绝不能将数据包序号重置为0，请参见第17.2.3节。

版本协商数据包没有加密保护。协商的结果必须作为加密握手的一部分重新验证（参见第7.3.3节）。

#### 6.3 使用保留版本

对于将来使用新版本的服务端，客户端必须正确处理不受支持的版本。为了帮助确保这一点，服务端应该在生成版本协商数据包时包含保留版本（参见第15节）。

版本协商的设计允许服务端避免以这种方式维护它拒绝的数据包的状态。版本协商的验证（参见第7.3.3节）仅验证版本协商的结果，无论发送哪个保留版本，都是相同的。因此，服务端可以在版本协商包及其传输参数中发送不同的保留版本号。

客户端可以使用保留的版本号发送数据包。这可用于从服务端请求支持的版本列表。

### 7. 密码和传输握手

QUIC依赖于组合的加密和传输握手来最小化连接建立延迟。 QUIC使用CRYPTO帧（第19.6节）来传输加密握手。 QUIC的版本0x00000001使用TLS，如[QUIC-TLS]中所述；不同的QUIC版本号可能表示正在使用不同的加密握手协议。

QUIC提供可靠，有序的加密握手数据传送。 QUIC数据包保护用于尽可能多地加密握手协议。加密握手必须提供以下属性：

- 认证密钥交换，
  - 始终对服务端进行身份验证，
  - 客户端可选地进行身份验证，
  - 每个连接产生不同的和不相关的密钥，
  - 密钥材料可用于0-RTT和1-RTT数据包的数据包保护，
  - 1-RTT密钥具有前向保密性
- 对等体传输参数的验证（参见第7.3节）
- 经过身份验证的版本协商确认（参见第7.3.3节）
- 经过身份验证的应用协议协商（TLS为此目的使用ALPN [RFC7301]）

来自客户端的第一个CRYPTO帧必须在一个数据包中发送。由地址验证触发的任何第二次尝试（参见第8.1节）也必须在单个数据包内发送。这避免了必须从多个数据包重新组装消息。

端点可以在其发送的第一个数据包中验证对显式拥塞通知（ECN）的支持，如第13.3.2节中所述。

CRYPTO帧可以在不同的数据包序号空间中发送。 CRYPTO帧用于确保加密握手数据的有序传送的序列号在每个数据包序号空间中从零开始。

端点必须明确地协商应用协议。这避免了对正在使用的协议存在分歧的情况。

#### 7.1 示例握手流程

有关如何将TLS与QUIC集成的详细信息，请参见[QUIC-TLS]，但此处提供了一些示例。第8.1.1节显示了此交换的扩展以支持客户端地址验证。

完成任何版本协商和地址验证交换后，加密握手用于就加密密钥达成一致。加密握手在初始化数据包（第17.2.2节）和握手数据包（第17.2.4节）中进行。

图4提供了1-RTT握手的概述。每行显示一个QUIC数据包，首先显示数据包类型和数据包序号，然后是通常包含在这些数据包中的帧。因此，例如，第一个数据包的类型为Initial，数据包编号为0，并包含一个携带ClientHello的CRYPTO帧。

请注意，多个QUIC数据包（即使是不同的加密级别）可以合并为单个UDP数据报（请参阅第12.2节），因此此握手可能包含少至4个UDP数据报，或者更多数量。例如，服务器的第一个发送包含来自初始加密级别（混淆），握手级别和来自服务器的1-RTT加密级别的”0.5-RTT数据”的数据包。

```
Client                                                  Server
Initial[0]: CRYPTO[CH] ->
                                 Initial[0]: CRYPTO[SH] ACK[0]
                       Handshake[0]: CRYPTO[EE, CERT, CV, FIN]
                                 <- 1-RTT[0]: STREAM[1, "..."]
Initial[1]: ACK[0]
Handshake[0]: CRYPTO[FIN], ACK[0]
1-RTT[0]: STREAM[0, "..."], ACK[0] ->

                           1-RTT[1]: STREAM[55, "..."], ACK[0]
                                       <- Handshake[1]: ACK[0]
```

图5显示了具有0-RTT握手和单个0-RTT数据包的连接的示例。请注意，如第12.3节所述，服务器在1-RTT加密级别确认0-RTT数据，客户端在相同的数据包编号空间中发送1-RTT数据包。

```
Client                                                  Server
Initial[0]: CRYPTO[CH]
0-RTT[0]: STREAM[0, "..."] ->
                                 Initial[0]: CRYPTO[SH] ACK[0]
                        Handshake[0] CRYPTO[EE, CERT, CV, FIN]
                          <- 1-RTT[0]: STREAM[1, "..."] ACK[0]
Initial[1]: ACK[0]
Handshake[0]: CRYPTO[FIN], ACK[0]
1-RTT[2]: STREAM[0, "..."] ACK[0] ->
                         1-RTT[1]: STREAM[55, "..."], ACK[1,2]
                                       <- Handshake[1]: ACK[0]
```

#### 7.2 协商连接ID

连接ID用于确保数据包的一致路由，如第5.1节所述。长标头包含两个连接ID：目标连接ID由数据包的接收者选择，用于提供一致的路由；源连接ID用于设置对等体使用的目标连接ID。

在握手期间，具有长报头的数据包（第17.2节）用于建立每个端点使用的连接ID。每个端点都使用“源连接ID”字段来指定在发送给它们的数据包的“目标连接ID”字段中使用的连接ID。收到数据包后，每个端点都会设置它发送的目标连接ID，以匹配它们收到的源连接ID的值。

当先前未从服务器接收到重试数据包的客户端发送初始数据包时，它会使用不可预测的值填充目标连接ID字段。这必须至少8个字节长。在从服务器接收到数据包之前，客户端必须使用相同的值，除非它放弃连接尝试并启动新连接。初始目标连接ID用于确定初始数据包的数据包保护密钥。

用于连接的最终版本可能与客户端的第一个初始化数据包版本不同。为了通过握手实现一致的路由，客户端应该选择一个足够长的初始目标连接ID长度，以满足它支持的每个QUIC版本的最小大小。

客户端使用其选择的值填充源连接ID字段，并将SCIL字段设置为匹配。

服务器的初始数据包中的目标连接ID字段包含由数据包的接收者（即客户端）选择的连接ID；源连接ID包括数据包发送方希望使用的连接ID（参见第5.1节）。服务器必须在握手期间使用一致的源连接ID。

在首次从服务器接收初始化数据包或重试数据包时，客户端使用服务器提供的源连接ID作为后续数据包的目标连接ID。这意味着客户端可能在连接建立期间两次更改目标连接ID，一次响应重试，一次响应来自服务器的第一个初始数据包。一旦客户端收到来自服务器的初始数据包，它必须丢弃它使用不同的源连接ID接收的任何数据包。

客户端必须仅更改它在目标连接ID中发送的值，以响应它从服务器接收的每种类型的第一个数据包（重试或初始）；服务器必须根据初始化数据包设置其值。不允许任何其他更改；如果这些类型的后续数据包包含不同的源连接ID，则必须丢弃它们。这避免了由于多个初始分组的无状态处理而产生的问题，这些初始分组产生不同的连接ID。

连接ID可以在连接的生命周期内发生变化，特别是在响应连接迁移时（第9节），有关详细信息，请参见第5.1.1节。

#### 7.3 传输参数

在建立连接期间，两个端点都会对其传输参数进行经过身份验证的声明。这些声明由每个端点单方面做出。端点必须符合这些参数所隐含的限制；每个参数的描述包括其处理规则。

第18节详细介绍了传输参数的编码。

QUIC包括加密握手中的编码传输参数。握手完成后，对等体声明的传输参数可用。每个端点验证其对等方提供的值。特别是，在认为连接建立正确完成之前，必须验证版本协商（参见第7.3.3节）。

每个定义的传输参数的定义包含在第18.1节中。端点必须将带有无效值的传输参数的接收视为TRANSPORT_PARAMETER_ERROR类型的连接错误。任何给定的参数必须在给定的传输参数扩展中最多出现一次。端点必须将重复传输参数的接收视为TRANSPORT_PARAMETER_ERROR类型的连接错误。

如果服务器发送了重试数据包以启用重试验证，则它必须包含original_connection_id传输参数（第18.1节），如第17.2.5节所述。

##### 7.3.1 0-RTT的传输参数

尝试发送0-RTT数据的客户端必须记住服务器使用的传输参数。服务器在连接建立期间通告的传输参数适用于使用在该握手期间建立的密钥材料恢复的所有连接。记住的传输参数适用于新连接，直到握手完成并且可以提供来自服务器的新传输参数。

服务器可以记住它所通告的传输参数，或者在故障单中存储受完整性保护的值副本，并在接受0-RTT数据时恢复信息。服务器使用传输参数来确定是否接受0-RTT数据。

服务器可以接受0-RTT，然后为传输参数提供不同的值，以便在新连接中使用。如果服务器接受0-RTT数据，则服务器不得减少任何限制或更改客户端使用其0-RTT数据可能违反的任何值。特别是，接受0-RTT数据的服务器绝不能为以下参数（第18.1节）设置小于这些参数的记忆值的值。

- initial_max_data
- initial_max_stream_data_bidi_local
- initial_max_stream_data_bidi_remote
- initial_max_stream_data_uni
- initial_max_streams_bidi
- initial_max_streams_uni

省略或设置某些传输参数的零值可能导致启用0-RTT数据，但不可用。允许发送应用程序数据的适用的传输参数子集应该设置为0-RTT的非零值。这包括initial_max_data和initial_max_streams_bidi和initial_max_stream_data_bidi_remote，或者initial_max_streams_uni和initial_max_stream_data_uni。

建立新连接时，不得使用服务器上一个preferred_address的值；相反，客户端应该等待在握手中观察服务器的新preferred_address值。

如果不支持传输参数的隐含值，服务器必须拒绝0-RTT数据或中止握手。

##### 7.3.2 新的传输参数

新的传输参数可用于协商新的协议行为。端点必须忽略它不支持的传输参数。因此，缺少传输参数会禁用使用该参数协商的任何可选协议功能。

可以根据第22.1节中的规则注册新的传输参数。

##### 7.3.3 版本协商验证

虽然加密握手具有完整性保护，但两种形式的QUIC版本降级是可能的。首先，攻击者替换初始数据包中的QUIC版本。在第二种情况下，攻击者会发送伪版本协商数据包。为了防止这些攻击，传输参数包括编码版本信息的三个字段。这些参数用于追溯验证版本的选择（参见第6节）。





