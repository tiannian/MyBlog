---
title: 有关QUIC的随笔 - 如何为IoT设备实施QUIC协议（未完成）
date: 2019-02-16 21:21:56
tags:
  - QUIC
  - thinking
  - Strobe
  - Noise
  - Disco
---

最近翻译了IETF的QUIC协议提案，在翻译的过程中对QUIC协议有了更深入的理解。同时也思考了一些与QUIC的问题，尤其是针对如何在IoT设备环境中实施QUIC协议进行了一些思考。

QUIC协议最开始是Google设计的用来代替TCP的运输层协议。与TCP不同的是，QUIC工作于应用程序中，而并非工作于操作系统内核中。QUIC更加适配HTTP/2，根据Google给出的数据，基于QUIC的HTTP/2性能好于基于TCP的HTTP/2。IETF甚至将HTTP/2 over QUIC称之为HTTP/3。但IETF给出的协议提案与Google的原始实现并不相同，同时也删除了一些功能。

但在阅读QUIC协议提案时，笔者也发现了一些问题。其中最大的问题时QUIC协议是为HTTP通讯而设计。当笔者考虑将QUIC协议实施于IoT环境下时，发现QUIC的实现过于庞大，同时对设备资源需求较高。QUIC本身确实拥有一些适合于物联网环境的特性，本文就来讨论下如何在IoT设备上实施QUIC协议，避免实施QUIC时会遇到的问题。

<!-- more -->

## QUIC协议与IoT

Web技术虽然现在开发工具很多，浏览器的实现也各不相同，但大家在协议层都支持HTTP协议。无论这些支持的HTTP协议版本有什么区别，但是至少都支持一个最低子集。然而不同于现有Web技术的情况，IoT领域到目前为止并没有一套统一的网络协议可供使用，不同的解决方案采用了不同的通讯协议。

现有在IoT上的实现主要分为两类，一类是基于UDP实现的应用层协议，最出名的例子就是CoAP协议；另外一类则是基于TCP协议实现，这一类协议的代表就是MQTT协议。但这些协议都是应用层协议，并非是传输层协议。传输层协议在IoT上的实现由嵌入式网络协议栈提供。这两类方案各有优缺点。

### 为什么QUIC协议是IoT设备的良伴

IoT设备所处的网络环境十分的复杂，节点间存在各种各样的连接方式，两个节点间也可能存在很多条路由。具体来说，IoT节点间的连接有如下特性：

- 通讯流量较小：除了OTA等场景下，在相同时间段内，IoT节点需要传递的数据量远小于Web服务。
- 需要长连接：为了保证对节点的持续控制，降低节点缓存数据的压力，IoT节点间需要维持长时间的连接
- 低延时需求：对于执行用户指令的IoT设备，需要尽量降低指令传递过程中的延时，保证指令尽快的执行。
- 网络连接不稳定：IoT节点的网络接入方式可能远没有Web服务稳定，节点需要经常进行连接恢复。有时候双方节点的IP地址等信息都可能发生变化。
- 多层穿越：对于在家庭内部使用的智能设备，节点往往位于多层设备之后，需要经过多条路由。
- 加密与安全性需求：IoT设备传递的大多数属于较为隐私的数据，为了保证数据的安全，需要在链路上实施高级的密码学安全保护。

QUIC提供的很多特性可以满足如上的需求。

首先QUIC的设计中原生支持TLS或者其他密码学协议，利用这样的方式QUIC上传输的数据包都会被加密验证，保证数据传输过程中的安全性。

其次，不同于传统TCP使用<源IP，源端口，目标IP，目标端口>四元组来表示连接，QUIC使用连接ID标记连接，通过这样的方法，两个节点间的连接可以轻易的迁移，解决UDP穿越NAT数据包改写的问题。同时由于QUIC的0-RTT特性，当连接迁移时，不需重新对连接的密钥进行重新协商。

最后由于原始的TCP流量控制协议为大流量应用设计，主要解决流量而不是延时问题。而IoT环境下网络往往不需要传递很大的流量，而是对延时需求较高，对流量需求则不高。QUIC的丢失检测和拥塞控制算法可以自由的被替换，针对不同的场景可以替换成不同的算法，以匹配不同的场景。

### 为什么难以在IoT设备上实施QUIC协议

虽然说QUIC协议拥有以上适用于IoT的特征，但当我们在准备IoT环境下实施QUIC协议时，我们会发现以下问题：

- TLS难以在IoT设备上实施：QUIC基于TLS设计，但TLS过于庞大难以在IoT设备上进行实施。
- QUIC过于复杂：同样的问题也出现在QUIC上，QUIC引入了大量适配HTTP/2的机制，包括流复用等，这些机制过于复杂也导致了QUIC同样难以在IoT上实施。
- 丢失检测和拥塞控制算法需要变更：QUIC默认采用的是TCP的NewReno算法，而针对低延时低流量需求的场景可以选择新的算法。

以上这些均是导致我们难以在IoT设备上实施QUIC协议的原因。

## 如何修改QUIC协议

虽然说QUIC协议有以上问题，但是IETF的提案提出的QUIC协议拥有十分良好的设计。利用这样的设计，我们可以对针对IoT上的实现单独进行一些修改。并且借助于QUIC提供的版本协商机制，这些新的修改也不会对原有的QUIC协议造成影响。

### QUIC的逻辑结构

在修改原始QUIC协议之前，我们需要明确现有的QUIC是什么样的结构。IETF针对QUIC提出的提案一共有6个，分别是如下：

- **Invariants** - 定义了最基础的QUIC协议的结构，定义了数据包的基础结构。只有满足这个提案中描述的协议才可以被称为QUIC协议。在这个提案的基础上可以针对不同版本的QUIC进行协商。
- **Transport** - 在**Invariants**基础上定义的**第一个版本**的QUIC协议，其中定义了QUIC协议的本体，包括了连接建立，流复用，数据包与帧描述，加密认证握手框架，拥塞控制框架等机制。
- **Recovery** - 定义了QUIC中具体的丢失检测和拥塞控制算法。
- **TLS** - 定义了如何使用TLS握手，加密认证数据包。
- **HTTP** - 定义了如何在QUIC上实现HTTP/2，也就是传说中的HTTP/3（HTTP/2 over QUIC）。
- **QPACK** - 定义了如何在HTTP/3上对HTTP头进行压缩。

从整体来看QUIC协议拥有以下图示的架构：

![](quic-drafts.png)

其中需要说明的是，其中TLS握手被独立出来，而TLS对数据包进行加密与认证与QUIC传输层相互依赖。TLS为QUIC提供握手机制，QUIC为TLS提供顺序数据包传输的机制。

在这个架构设计中，在保持下一层不变的基础上，上一层的内容可以被无痛的替换。例如：当我们觉得TLS的握手机制不适合，就可以只替换TLS，保持其他部分不发生变化。

### 寻找TLS的替代品

### 寻找Cubic的替代品

### 阉割QUIC

### 可以选择的应用层协议

## cQUIC





