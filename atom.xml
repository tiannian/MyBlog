<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NianZhe</title>
  
  <subtitle>Nian is made up by Jin and Xin</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tiannian.github.io/"/>
  <updated>2019-02-17T05:40:23.515Z</updated>
  <id>https://tiannian.github.io/</id>
  
  <author>
    <name>Tiannian Du</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>有关QUIC的随笔 - 如何为IoT设备实施QUIC协议</title>
    <link href="https://tiannian.github.io/2019/02/16/network/quic/thinking-of-quic-protocol-for-iot/"/>
    <id>https://tiannian.github.io/2019/02/16/network/quic/thinking-of-quic-protocol-for-iot/</id>
    <published>2019-02-16T13:21:56.000Z</published>
    <updated>2019-02-17T05:40:23.515Z</updated>
    
    <content type="html"><![CDATA[<p>最近翻译了IETF的QUIC协议提案，在翻译的过程中对QUIC协议有了更深入的理解。同时也思考了一些与QUIC的问题，尤其是针对如何在IoT设备环境中实施QUIC协议进行了一些思考。</p><p>QUIC协议最开始是Google设计的用来代替TCP的运输层协议。与TCP不同的是，QUIC工作于应用程序中，而并非工作于操作系统内核中。QUIC更加适配HTTP/2，根据Google给出的数据，基于QUIC的HTTP/2性能好于基于TCP的HTTP/2。IETF甚至将HTTP/2 over QUIC称之为HTTP/3。但IETF给出的协议提案与Google的原始实现并不相同，同时也删除了一些功能。</p><p>但在阅读QUIC协议提案时，笔者也发现了一些问题。其中最大的问题时QUIC协议是为HTTP通讯而设计。当笔者考虑将QUIC协议实施于IoT环境下时，发现QUIC的实现过于庞大，同时对设备资源需求较高。QUIC本身确实拥有一些适合于物联网环境的特性，本文就来讨论下如何在IoT设备上实施QUIC协议，避免实施QUIC时会遇到的问题。</p><a id="more"></a><h2 id="quic协议与iot">QUIC协议与IoT</h2><h3 id="为什么quic协议是iot设备的良伴">为什么QUIC协议是IoT设备的良伴</h3><h3 id="为什么难以在iot设备上实施quic协议">为什么难以在IoT设备上实施QUIC协议</h3><h2 id="如何修改quic协议">如何修改QUIC协议</h2><h3 id="quic的逻辑结构">QUIC的逻辑结构</h3><h3 id="寻找tls的替代品">寻找TLS的替代品</h3><h3 id="寻找cubic的替代品">寻找Cubic的替代品</h3><h3 id="阉割quic">阉割QUIC</h3><h3 id="可以选择的应用层协议">可以选择的应用层协议</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近翻译了IETF的QUIC协议提案，在翻译的过程中对QUIC协议有了更深入的理解。同时也思考了一些与QUIC的问题，尤其是针对如何在IoT设备环境中实施QUIC协议进行了一些思考。&lt;/p&gt;
&lt;p&gt;QUIC协议最开始是Google设计的用来代替TCP的运输层协议。与TCP不同的是，QUIC工作于应用程序中，而并非工作于操作系统内核中。QUIC更加适配HTTP/2，根据Google给出的数据，基于QUIC的HTTP/2性能好于基于TCP的HTTP/2。IETF甚至将HTTP/2 over QUIC称之为HTTP/3。但IETF给出的协议提案与Google的原始实现并不相同，同时也删除了一些功能。&lt;/p&gt;
&lt;p&gt;但在阅读QUIC协议提案时，笔者也发现了一些问题。其中最大的问题时QUIC协议是为HTTP通讯而设计。当笔者考虑将QUIC协议实施于IoT环境下时，发现QUIC的实现过于庞大，同时对设备资源需求较高。QUIC本身确实拥有一些适合于物联网环境的特性，本文就来讨论下如何在IoT设备上实施QUIC协议，避免实施QUIC时会遇到的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="network" scheme="https://tiannian.github.io/categories/network/"/>
    
      <category term="quic" scheme="https://tiannian.github.io/categories/network/quic/"/>
    
    
      <category term="QUIC" scheme="https://tiannian.github.io/tags/QUIC/"/>
    
      <category term="thinking" scheme="https://tiannian.github.io/tags/thinking/"/>
    
      <category term="Strobe" scheme="https://tiannian.github.io/tags/Strobe/"/>
    
      <category term="Noise" scheme="https://tiannian.github.io/tags/Noise/"/>
    
      <category term="Disco" scheme="https://tiannian.github.io/tags/Disco/"/>
    
  </entry>
  
  <entry>
    <title>QUIC协议翻译 - draft-ietf-quic-transport-latest Part 3.（未完成）</title>
    <link href="https://tiannian.github.io/2019/02/15/network/quic/draft-ietf-quic-transport-latest-3/"/>
    <id>https://tiannian.github.io/2019/02/15/network/quic/draft-ietf-quic-transport-latest-3/</id>
    <published>2019-02-15T13:41:11.000Z</published>
    <updated>2019-02-16T14:52:35.422Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对QUIC协议IETF提案：<a href="https://quicwg.org/base-drafts/draft-ietf-quic-transport.html" target="_blank" rel="noopener">draft-ietf-quic-transport-latest</a>翻译的第三部分。</p><p><a href="https://quicwg.org/base-drafts/draft-ietf-quic-transport.html" target="_blank" rel="noopener">draft-ietf-quic-transport-latest</a>是在<a href="https://quicwg.org/base-drafts/draft-ietf-quic-invariants.html" target="_blank" rel="noopener">draft-ietf-quic-invariants-latest</a>基础上定义的第一个版本的QUIC协议，这里描述了QUIC协议的核心，包括一些概念定义与具体的协议行为。</p><p>第三部分翻译内容包括第6，7，8节。内容包含连接建立，版本协商与如何地域DDoS攻击。</p><a id="more"></a><h3 id="版本协商">6. 版本协商</h3><p>版本协商可确保客户端和服务端同意相互支持的QUIC版本。服务端发送版本协商数据包以响应可能启动新连接的每个数据包，有关详细信息，请参阅第5.2节。</p><p>尝试与服务端建立新连接的客户端之间的交换的前几条消息如图3所示。版本协商完成后，可以继续建立连接，例如，如第7.1节所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Client                                                  Server</span><br><span class="line">Packet (v=X) -&gt;</span><br><span class="line">                        &lt;- Version Negotiation (supported=Y,Z)</span><br><span class="line">Packet (v=Y) -&gt;</span><br><span class="line">                                            &lt;- Packet(s) (v=Y)</span><br></pre></td></tr></table></figure><p>客户端发送的第一个数据包的大小将决定服务端是否发送版本协商数据包。支持多个QUIC版本的客户端应该将它们发送的第一个数据包填充到它们支持的所有版本中最大的最小数据包大小。这可确保服务端在存在相互支持的版本时进行响应。</p><h4 id="发送版本协商数据包">6.1 发送版本协商数据包</h4><p>如果客户端选择的版本对服务端不可接受，则服务端将使用版本协商数据包进行响应（请参阅第17.2.1节）。这包括服务端将接受的版本列表。端点不得使用版本协商数据包来响应版本协商数据包。</p><p>此系统允许服务端处理具有不受支持的版本的数据包而不保留状态。虽然响应中发送的初始数据包或版本协商数据包可能会丢失，但客户端将发送新数据包，直到它成功收到响应或放弃连接尝试。</p><p>服务端可以限制它发送的版本协商数据包的数量。例如，能够将分组识别为0-RTT的服务端可以选择不发送版本协商分组以响应0-RTT数据包，期望它最终将接收初始数据包。</p><h4 id="处理版本协商数据包">6.2 处理版本协商数据包</h4><p>当客户端收到版本协商数据包时，它首先检查目标和源连接ID字段是否与客户端发送的数据包中的源和目标连接ID字段匹配。如果此检查失败，则必须丢弃该数据包。</p><p>一旦确定版本协商分组有效，则客户端然后从服务端提供的列表中选择可接受的协议版本。然后，客户端尝试使用该版本创建连接。虽然客户端发送的初始数据包的内容可能不会响应版本协商而改变，但客户端必须增加它在发送的每个数据包上使用的数据包序号。数据包必须继续使用长包头（第17.2节），并且必须包含新的协商协议版本。</p><p>客户端必须使用长报头格式并在所有数据包中包含其选定版本，直到它具有1-RTT密钥并且它已从服务端接收到不是版本协商数据包的数据包。</p><p>客户端不得更改它使用的版本，除非它是响应来自服务端的版本协商数据包。一旦客户端收到来自服务端的不是版本协商数据包的数据包，它必须丢弃同一连接上的其他版本协商数据包。类似地，如果客户端已经收到并对版本协商数据包执行了操作，则它必须忽略版本协商数据包。</p><p>客户端必须忽略列出客户端所选版本的版本协商数据包。如果客户端不支持服务端提供的任何版本，则会中止连接尝试。</p><p>客户端可以在收到版本协商数据包后尝试0-RTT。发送附加0-RTT数据包的客户端绝不能将数据包序号重置为0，请参见第17.2.3节。</p><p>版本协商数据包没有加密保护。协商的结果必须作为加密握手的一部分重新验证（参见第7.3.3节）。</p><h4 id="使用保留版本">6.3 使用保留版本</h4><p>对于将来使用新版本的服务端，客户端必须正确处理不受支持的版本。为了帮助确保这一点，服务端应该在生成版本协商数据包时包含保留版本（参见第15节）。</p><p>版本协商的设计允许服务端避免以这种方式维护它拒绝的数据包的状态。版本协商的验证（参见第7.3.3节）仅验证版本协商的结果，无论发送哪个保留版本，都是相同的。因此，服务端可以在版本协商包及其传输参数中发送不同的保留版本号。</p><p>客户端可以使用保留的版本号发送数据包。这可用于从服务端请求支持的版本列表。</p><h3 id="密码和传输握手">7. 密码和传输握手</h3><p>QUIC依赖于组合的加密和传输握手来最小化连接建立延迟。 QUIC使用CRYPTO帧（第19.6节）来传输加密握手。 QUIC的版本0x00000001使用TLS，如[QUIC-TLS]中所述；不同的QUIC版本号可能表示正在使用不同的加密握手协议。</p><p>QUIC提供可靠，有序的加密握手数据传送。 QUIC数据包保护用于尽可能多地加密握手协议。加密握手必须提供以下属性：</p><ul><li>认证密钥交换，<ul><li>始终对服务端进行身份验证，</li><li>客户端可选地进行身份验证，</li><li>每个连接产生不同的和不相关的密钥，</li><li>密钥材料可用于0-RTT和1-RTT数据包的数据包保护，</li><li>1-RTT密钥具有前向保密性</li></ul></li><li>对等体传输参数的验证（参见第7.3节）</li><li>经过身份验证的版本协商确认（参见第7.3.3节）</li><li>经过身份验证的应用协议协商（TLS为此目的使用ALPN [RFC7301]）</li></ul><p>来自客户端的第一个CRYPTO帧必须在一个数据包中发送。由地址验证触发的任何第二次尝试（参见第8.1节）也必须在单个数据包内发送。这避免了必须从多个数据包重新组装消息。</p><p>端点可以在其发送的第一个数据包中验证对显式拥塞通知（ECN）的支持，如第13.3.2节中所述。</p><p>CRYPTO帧可以在不同的数据包序号空间中发送。 CRYPTO帧用于确保加密握手数据的有序传送的序列号在每个数据包序号空间中从零开始。</p><p>端点必须明确地协商应用协议。这避免了对正在使用的协议存在分歧的情况。</p><h4 id="示例握手流程">7.1 示例握手流程</h4><p>有关如何将TLS与QUIC集成的详细信息，请参见[QUIC-TLS]，但此处提供了一些示例。第8.1.1节显示了此交换的扩展以支持客户端地址验证。</p><p>完成任何版本协商和地址验证交换后，加密握手用于就加密密钥达成一致。加密握手在初始化数据包（第17.2.2节）和握手数据包（第17.2.4节）中进行。</p><p>图4提供了1-RTT握手的概述。每行显示一个QUIC数据包，首先显示数据包类型和数据包序号，然后是通常包含在这些数据包中的帧。因此，例如，第一个数据包的类型为Initial，数据包编号为0，并包含一个携带ClientHello的CRYPTO帧。</p><p>请注意，多个QUIC数据包（即使是不同的加密级别）可以合并为单个UDP数据报（请参阅第12.2节），因此此握手可能包含少至4个UDP数据报，或者更多数量。例如，服务器的第一个发送包含来自初始加密级别（混淆），握手级别和来自服务器的1-RTT加密级别的”0.5-RTT数据”的数据包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Client                                                  Server</span><br><span class="line">Initial[0]: CRYPTO[CH] -&gt;</span><br><span class="line">                                 Initial[0]: CRYPTO[SH] ACK[0]</span><br><span class="line">                       Handshake[0]: CRYPTO[EE, CERT, CV, FIN]</span><br><span class="line">                                 &lt;- 1-RTT[0]: STREAM[1, &quot;...&quot;]</span><br><span class="line">Initial[1]: ACK[0]</span><br><span class="line">Handshake[0]: CRYPTO[FIN], ACK[0]</span><br><span class="line">1-RTT[0]: STREAM[0, &quot;...&quot;], ACK[0] -&gt;</span><br><span class="line"></span><br><span class="line">                           1-RTT[1]: STREAM[55, &quot;...&quot;], ACK[0]</span><br><span class="line">                                       &lt;- Handshake[1]: ACK[0]</span><br></pre></td></tr></table></figure><p>图5显示了具有0-RTT握手和单个0-RTT数据包的连接的示例。请注意，如第12.3节所述，服务器在1-RTT加密级别确认0-RTT数据，客户端在相同的数据包编号空间中发送1-RTT数据包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Client                                                  Server</span><br><span class="line">Initial[0]: CRYPTO[CH]</span><br><span class="line">0-RTT[0]: STREAM[0, &quot;...&quot;] -&gt;</span><br><span class="line">                                 Initial[0]: CRYPTO[SH] ACK[0]</span><br><span class="line">                        Handshake[0] CRYPTO[EE, CERT, CV, FIN]</span><br><span class="line">                          &lt;- 1-RTT[0]: STREAM[1, &quot;...&quot;] ACK[0]</span><br><span class="line">Initial[1]: ACK[0]</span><br><span class="line">Handshake[0]: CRYPTO[FIN], ACK[0]</span><br><span class="line">1-RTT[2]: STREAM[0, &quot;...&quot;] ACK[0] -&gt;</span><br><span class="line">                         1-RTT[1]: STREAM[55, &quot;...&quot;], ACK[1,2]</span><br><span class="line">                                       &lt;- Handshake[1]: ACK[0]</span><br></pre></td></tr></table></figure><h4 id="协商连接id">7.2 协商连接ID</h4><p>连接ID用于确保数据包的一致路由，如第5.1节所述。长标头包含两个连接ID：目标连接ID由数据包的接收者选择，用于提供一致的路由；源连接ID用于设置对等体使用的目标连接ID。</p><p>在握手期间，具有长报头的数据包（第17.2节）用于建立每个端点使用的连接ID。每个端点都使用“源连接ID”字段来指定在发送给它们的数据包的“目标连接ID”字段中使用的连接ID。收到数据包后，每个端点都会设置它发送的目标连接ID，以匹配它们收到的源连接ID的值。</p><p>当先前未从服务器接收到重试数据包的客户端发送初始数据包时，它会使用不可预测的值填充目标连接ID字段。这必须至少8个字节长。在从服务器接收到数据包之前，客户端必须使用相同的值，除非它放弃连接尝试并启动新连接。初始目标连接ID用于确定初始数据包的数据包保护密钥。</p><p>用于连接的最终版本可能与客户端的第一个初始化数据包版本不同。为了通过握手实现一致的路由，客户端应该选择一个足够长的初始目标连接ID长度，以满足它支持的每个QUIC版本的最小大小。</p><p>客户端使用其选择的值填充源连接ID字段，并将SCIL字段设置为匹配。</p><p>服务器的初始数据包中的目标连接ID字段包含由数据包的接收者（即客户端）选择的连接ID；源连接ID包括数据包发送方希望使用的连接ID（参见第5.1节）。服务器必须在握手期间使用一致的源连接ID。</p><p>在首次从服务器接收初始化数据包或重试数据包时，客户端使用服务器提供的源连接ID作为后续数据包的目标连接ID。这意味着客户端可能在连接建立期间两次更改目标连接ID，一次响应重试，一次响应来自服务器的第一个初始数据包。一旦客户端收到来自服务器的初始数据包，它必须丢弃它使用不同的源连接ID接收的任何数据包。</p><p>客户端必须仅更改它在目标连接ID中发送的值，以响应它从服务器接收的每种类型的第一个数据包（重试或初始）；服务器必须根据初始化数据包设置其值。不允许任何其他更改；如果这些类型的后续数据包包含不同的源连接ID，则必须丢弃它们。这避免了由于多个初始分组的无状态处理而产生的问题，这些初始分组产生不同的连接ID。</p><p>连接ID可以在连接的生命周期内发生变化，特别是在响应连接迁移时（第9节），有关详细信息，请参见第5.1.1节。</p><h4 id="传输参数">7.3 传输参数</h4><p>在建立连接期间，两个端点都会对其传输参数进行经过身份验证的声明。这些声明由每个端点单方面做出。端点必须符合这些参数所隐含的限制；每个参数的描述包括其处理规则。</p><p>第18节详细介绍了传输参数的编码。</p><p>QUIC包括加密握手中的编码传输参数。握手完成后，对等体声明的传输参数可用。每个端点验证其对等方提供的值。特别是，在认为连接建立正确完成之前，必须验证版本协商（参见第7.3.3节）。</p><p>每个定义的传输参数的定义包含在第18.1节中。端点必须将带有无效值的传输参数的接收视为TRANSPORT_PARAMETER_ERROR类型的连接错误。任何给定的参数必须在给定的传输参数扩展中最多出现一次。端点必须将重复传输参数的接收视为TRANSPORT_PARAMETER_ERROR类型的连接错误。</p><p>如果服务器发送了重试数据包以启用重试验证，则它必须包含original_connection_id传输参数（第18.1节），如第17.2.5节所述。</p><h5 id="rtt的传输参数">7.3.1 0-RTT的传输参数</h5><p>尝试发送0-RTT数据的客户端必须记住服务器使用的传输参数。服务器在连接建立期间通告的传输参数适用于使用在该握手期间建立的密钥材料恢复的所有连接。记住的传输参数适用于新连接，直到握手完成并且可以提供来自服务器的新传输参数。</p><p>服务器可以记住它所通告的传输参数，或者在故障单中存储受完整性保护的值副本，并在接受0-RTT数据时恢复信息。服务器使用传输参数来确定是否接受0-RTT数据。</p><p>服务器可以接受0-RTT，然后为传输参数提供不同的值，以便在新连接中使用。如果服务器接受0-RTT数据，则服务器不得减少任何限制或更改客户端使用其0-RTT数据可能违反的任何值。特别是，接受0-RTT数据的服务器绝不能为以下参数（第18.1节）设置小于这些参数的记忆值的值。</p><ul><li>initial_max_data</li><li>initial_max_stream_data_bidi_local</li><li>initial_max_stream_data_bidi_remote</li><li>initial_max_stream_data_uni</li><li>initial_max_streams_bidi</li><li>initial_max_streams_uni</li></ul><p>省略或设置某些传输参数的零值可能导致启用0-RTT数据，但不可用。允许发送应用程序数据的适用的传输参数子集应该设置为0-RTT的非零值。这包括initial_max_data和initial_max_streams_bidi和initial_max_stream_data_bidi_remote，或者initial_max_streams_uni和initial_max_stream_data_uni。</p><p>建立新连接时，不得使用服务器上一个preferred_address的值；相反，客户端应该等待在握手中观察服务器的新preferred_address值。</p><p>如果不支持传输参数的隐含值，服务器必须拒绝0-RTT数据或中止握手。</p><h5 id="新的传输参数">7.3.2 新的传输参数</h5><p>新的传输参数可用于协商新的协议行为。端点必须忽略它不支持的传输参数。因此，缺少传输参数会禁用使用该参数协商的任何可选协议功能。</p><p>可以根据第22.1节中的规则注册新的传输参数。</p><h5 id="版本协商验证">7.3.3 版本协商验证</h5><p>虽然加密握手具有完整性保护，但两种形式的QUIC版本降级是可能的。首先，攻击者替换初始数据包中的QUIC版本。在第二种情况下，攻击者会发送伪版本协商数据包。为了防止这些攻击，传输参数包括编码版本信息的三个字段。这些参数用于追溯验证版本的选择（参见第6节）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对QUIC协议IETF提案：&lt;a href=&quot;https://quicwg.org/base-drafts/draft-ietf-quic-transport.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;draft-ietf-quic-transport-latest&lt;/a&gt;翻译的第三部分。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://quicwg.org/base-drafts/draft-ietf-quic-transport.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;draft-ietf-quic-transport-latest&lt;/a&gt;是在&lt;a href=&quot;https://quicwg.org/base-drafts/draft-ietf-quic-invariants.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;draft-ietf-quic-invariants-latest&lt;/a&gt;基础上定义的第一个版本的QUIC协议，这里描述了QUIC协议的核心，包括一些概念定义与具体的协议行为。&lt;/p&gt;
&lt;p&gt;第三部分翻译内容包括第6，7，8节。内容包含连接建立，版本协商与如何地域DDoS攻击。&lt;/p&gt;
    
    </summary>
    
      <category term="network" scheme="https://tiannian.github.io/categories/network/"/>
    
      <category term="quic" scheme="https://tiannian.github.io/categories/network/quic/"/>
    
    
      <category term="QUIC" scheme="https://tiannian.github.io/tags/QUIC/"/>
    
      <category term="translate" scheme="https://tiannian.github.io/tags/translate/"/>
    
      <category term="RFC" scheme="https://tiannian.github.io/tags/RFC/"/>
    
      <category term="Protocol" scheme="https://tiannian.github.io/tags/Protocol/"/>
    
  </entry>
  
  <entry>
    <title>打造基于git的跨平台密码管理器</title>
    <link href="https://tiannian.github.io/2019/02/15/Instrumentalism/build-more-secure-pass-manager/"/>
    <id>https://tiannian.github.io/2019/02/15/Instrumentalism/build-more-secure-pass-manager/</id>
    <published>2019-02-15T01:29:40.000Z</published>
    <updated>2019-02-15T12:19:14.600Z</updated>
    
    <content type="html"><![CDATA[<p>现在互联网的发达程度，导致我们对需要管理并维护很多属于自己的账号信息。很多人为了自己方便起见，将自己的所有账户的密码设置为同一个。这样虽然方便，但一旦一个账户的密码泄露，所有的账号都会被一锅端。因此密码管理工具应运而生。</p><p>当前最流行的密码管理工具应该就是1Password与LastPassword。然而作为商业软件，这种软件不仅仅需要付费使用，同时用户需要完全信任这种软件运营开发公司，由于其代码封闭，难以审计，很难说在你将自己的密码交给他之后会被做什么。</p><p>因此，结合现有的开源方案，在这里提出一套可以媲美1Password等商业方案的密码管理解决方案。</p><p>总体来说这套方案适用于如下需求：</p><ul><li>希望免费拥有一套免费密码管理方案；</li><li>不信任1Password，LastPassword这种中心化密码管理方案；</li><li>有一定的技术能力。</li></ul><a id="more"></a><h2 id="使用工具">使用工具</h2><p>这套方案需要使用如下几个工具相互配合来实现：</p><ul><li><p>git - 分布式版本管理软件，用于管理加密后的密码库，同时负责跨平台的同步密码库。</p></li><li>pass - 管理并组织密码库的软件，提供多种跨平台客户端。</li><li>gunpg - OpenPGP的实现，负责加密认证密码库。</li><li><p>github - 作为密钥库存储的中央仓库，github现在提供免费的私有仓库，也可以采用其他的托管仓库。</p></li></ul><p>## 安装与配置</p><p>由于不同操作系统之间的差异，因此在安装、配置的时候需要根据不同的操作系统区别进行。</p><p>首先需要拥有一个github仓库或者其他支持git协议的托管仓库。</p><h3 id="linux">Linux</h3><p>区别于不同的发行版，Linux可以选择并采用不同的方式去安装软件。需要安装的软件包括如下：</p><ul><li><a href="https://www.passwordstore.org/" target="_blank" rel="noopener">pass</a> - 原始版本的pass密码管理器</li><li><a href="https://www.gnupg.org/" target="_blank" rel="noopener">gnupg2</a> - GPG2，必须</li><li><a href="https://git-scm.com/" target="_blank" rel="noopener">git</a> - 版本管理工具，必须</li><li><a href="http://qtpass.org/" target="_blank" rel="noopener">qtpass</a> - 图形化pass密码管理器，与原始版本pass二选其一即可，也可以共存。</li></ul><p>首先你需要创建一个gpg密钥，可以生成一个新的，也可以将你已有的gpg密钥导入当前电脑上。</p><p>如果你采用图形化密码管理器qtpass，参见Windows系统下的配置方法；如果采用命原始的pass密码管理器，首先需要初始化你的密码存储库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> pass init "&lt;你的gpg公钥ID&gt;"</span><br></pre></td></tr></table></figure><p>之后你可以利用git初始化这个密钥仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> pass git init</span><br></pre></td></tr></table></figure><p>之后添加托管仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> pass git remote add origin &lt;仓库的远程地址&gt;</span><br></pre></td></tr></table></figure><p>Linux下默认的密码库会被存储在<code>~/.password-store</code>目录下。</p><h3 id="windows">Windows</h3><p>windows系统下可以避免在命令行下工作，使用图形化界面完成操作，除了git之外。</p><p>首先你需要下载并安装如下软件：</p><ul><li><a href="https://www.gpg4win.org/" target="_blank" rel="noopener">gpg4win</a> - windows上的gpg加密软件（可选图形化界面）；</li><li><a href="https://tortoisegit.org/" target="_blank" rel="noopener">TortoiseGit</a> - windows上的git软件（图形界面）；</li><li><a href="http://qtpass.org/" target="_blank" rel="noopener">qtpass</a> - 图形化pass密码管理器。</li></ul><p>在安装好之后，首先配置git，如果你之前使用过git，并且完成过配置可以忽略此步骤；</p><p>之后使用gpg4win提供的图形化密钥管理软件Kleopatra生成或导入属于自己的gpg密钥；</p><p>使用TortoiseGit在需要放置密码库的位置初始化git仓库，并添加托管仓库的远程地址；</p><p>最后运行QtPass，在设置页面的用用户选项卡中设置密码库。</p><h3 id="android">Android</h3><p>安卓系统下使用，只需要两个软件即可，分别是：</p><ul><li>Password Store - pass密码管理器的安卓版，自带git版本管理；</li><li>OpenKeyChain - gpg的安卓版本，管理私钥。</li></ul><p>安卓上配置则较为简单，只需要生成或导入gpg密钥，同时在Password Store中配置远端托管仓库即可。</p><h3 id="ios">iOS</h3><p>iOS端可以使用pass-password-store来管理并同步属于你的密码。</p><h2 id="生成密码">生成密码</h2><p>不同平台的采用的客户端不相同，则生成新密码的方式各不相同。pass将密码库中的密码以文件夹的形式进行管理，你可以自由的选择密码的组织方式。</p><h3 id="pass-命令">pass 命令</h3><p>如果你使用pass命令来生成新密码，则在shell中执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> pass generate Email/aliyun.com 15</span><br></pre></td></tr></table></figure><p>这个命令会在Email目录下生成一个名为aliyun.com的文件，同时会在命令行输出一个长度为15的随机密码。整个文件会采用gpg加密存储。当然你需要在生成的时候输入gpg的口令。</p><p>在生成新密码之后，你需要手动使用git管理密码库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> pass git add -A</span><br><span class="line"><span class="meta">$</span> pass git commit -m "add password"</span><br><span class="line"><span class="meta">$</span> pass git push -u origin master</span><br></pre></td></tr></table></figure><h3 id="qtpass">QtPass</h3><p>如果你使用qtpass来进行图形化的管理，则只需要点击新密码按钮，之后生成你需要长度的密码，点击生成即可生成新密码。当你点下确认保存密码之后，QtPass会自动帮你管理提交密码库到远端托管仓库中。</p><h3 id="password-store">Password Store</h3><p>Password Store可以非常轻易的创建新的密码，生成密码之后只需选择功能菜单中的git pull与git push就可以与托管仓库进行同步。</p><h2 id="otp">OTP</h2><p>OTP多用于两步验证过程，pass也是可以支持OTP，根据不同的实现，支持程度略有不同。pass命令需要安装otp扩展，Password Store可以直接支持，而QtPass则完全不支持。</p><p>在添加OTP时，网站上往往会给出一个二维码，这个二维码中记录了一个字符串，用于描述OTP的具体细节。在pass中使用时，由于pass管理的密码库本质上就是一个经过加密的文本文件，因此只需将二维码中的字符串写在文件中独立的一行即可。凡是可以使用谷歌手机验证器进行的两步验证都可以在pass中管理。</p><p>pass命令使用的扩展可以使用如下命令添加新的OTP：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> pass otp insert Email/aliyun.com # 创建一个新的密码文件用于记录otp，存储在Email/aliyun.com</span><br><span class="line"><span class="meta">$</span> pass otp append Email/aliyun.com # 添加otp到密码文件Email/aliyun.com中</span><br></pre></td></tr></table></figure><p>生成新的OTP码只需要：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> pass otp Email/aliyun.com</span><br></pre></td></tr></table></figure><h2 id="reference">Reference</h2><ul><li><a href="https://www.passwordstore.org/" target="_blank" rel="noopener">pass</a></li><li><a href="https://github.com/tadfisher/pass-otp" target="_blank" rel="noopener">pass-otp</a></li><li><a href="http://www.ruanyifeng.com/blog/2013/07/gpg.html" target="_blank" rel="noopener">GPG入门教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在互联网的发达程度，导致我们对需要管理并维护很多属于自己的账号信息。很多人为了自己方便起见，将自己的所有账户的密码设置为同一个。这样虽然方便，但一旦一个账户的密码泄露，所有的账号都会被一锅端。因此密码管理工具应运而生。&lt;/p&gt;
&lt;p&gt;当前最流行的密码管理工具应该就是1Password与LastPassword。然而作为商业软件，这种软件不仅仅需要付费使用，同时用户需要完全信任这种软件运营开发公司，由于其代码封闭，难以审计，很难说在你将自己的密码交给他之后会被做什么。&lt;/p&gt;
&lt;p&gt;因此，结合现有的开源方案，在这里提出一套可以媲美1Password等商业方案的密码管理解决方案。&lt;/p&gt;
&lt;p&gt;总体来说这套方案适用于如下需求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;希望免费拥有一套免费密码管理方案；&lt;/li&gt;
&lt;li&gt;不信任1Password，LastPassword这种中心化密码管理方案；&lt;/li&gt;
&lt;li&gt;有一定的技术能力。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Instrumentalism" scheme="https://tiannian.github.io/categories/Instrumentalism/"/>
    
    
      <category term="git" scheme="https://tiannian.github.io/tags/git/"/>
    
      <category term="gunpg" scheme="https://tiannian.github.io/tags/gunpg/"/>
    
      <category term="password manager" scheme="https://tiannian.github.io/tags/password-manager/"/>
    
      <category term="pass" scheme="https://tiannian.github.io/tags/pass/"/>
    
  </entry>
  
  <entry>
    <title>QUIC协议翻译 - draft-ietf-quic-transport-latest Part 2.</title>
    <link href="https://tiannian.github.io/2019/02/14/network/quic/draft-ietf-quic-transport-latest-2/"/>
    <id>https://tiannian.github.io/2019/02/14/network/quic/draft-ietf-quic-transport-latest-2/</id>
    <published>2019-02-14T05:34:06.000Z</published>
    <updated>2019-02-16T14:51:41.774Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对QUIC协议IETF提案：<a href="https://quicwg.org/base-drafts/draft-ietf-quic-transport.html" target="_blank" rel="noopener">draft-ietf-quic-transport-latest</a>翻译的第二部分。</p><p><a href="https://quicwg.org/base-drafts/draft-ietf-quic-transport.html" target="_blank" rel="noopener">draft-ietf-quic-transport-latest</a>是在<a href="https://quicwg.org/base-drafts/draft-ietf-quic-invariants.html" target="_blank" rel="noopener">draft-ietf-quic-invariants-latest</a>基础上定义的第一个版本的QUIC协议，这里描述了QUIC协议的核心，包括一些概念定义与具体的协议行为。</p><p>第二部分翻译内容包括第4，5节。内容包括流量控制与连接等概念。</p><a id="more"></a><h3 id="流量控制">4. 流量控制</h3><p>为了防止发送方的速度过快从而导致接收者难以接受数据，或防止恶意发送方在接收方处消耗大量内存，有必要限制接收方可以缓冲的数据量，为了使接收方能够限制对连接的内存，并对发送方实施调控，流被单独地和作为聚合流控制。QUIC接收方控制发送方可以在流上发送的最大数据量，如第4.1节和第4.2节所述。</p><p>同样，为了限制连接中的并发性，QUIC端点控制其对等方可以启动的最大累积流数，如第4.5节所述。</p><p>在CRYPTO帧中发送的数据的流控制方式与流数据的流控制方式不同。 QUIC依赖于加密协议实现来避免过度缓冲数据，请参阅[QUIC-TLS]。具体的实现中应该为QUIC提供一个接口来告诉QUIC它的缓冲限制，以便在限制不同层次上过多的缓冲。</p><h4 id="数据流量控制">4.1 数据流量控制</h4><p>QUIC采用类似于HTTP/2 [HTTP2]中基于信用分数（credit）的流控制方案，其中接收方通告它准备在给定流和整个连接上接收的字节数。这产生了QUIC中的两级数据流控制：</p><ul><li>流级流量控制，通过限制可在任何流上发送的数据量，防止单个流消耗连接的整个接收缓冲区。</li><li>连接级流量控制，通过限制所有流上STREAM帧中发送的流数据的总字节数，防止发送者超过接收者的连接缓冲容量。</li></ul><p>接收方通过在握手期间发送传输参数来设置所有流的初始信用分数（credit）（第7.3节）。接收方向发送方发送MAX_STREAM_DATA（第19.10节）或MAX_DATA（第19.9节）帧，以通告增加的信用分数（credit）。</p><p>接收方通过发送MAX_STREAM_DATA帧并适当地设置流ID字段来通告流的信用分数（credit）。MAX_STREAM_DATA帧指示流的最大绝对字节偏移量。接收方可以使用当前消耗的数据偏移量来确定被通告的流量控制偏移量。接收方可以在多个数据包中发送MAX_STREAM_DATA帧，即使其中一个数据包丢失了，也可以确保发送方在消耗完流控制信用分数（credit）之前收到更新。</p><p>接收方通过发送MAX_DATA帧来通告连接信用分数（credit），该帧指示所有流的绝对字节偏移之和的最大值。接收方维护在所有流上接收的累积字节总和，用于检查流控制违规。接收方可以使用所有流上消耗的字节总数来确定要通告的最大数据限制。</p><p>接收方可以通过在连接期间的任何时间发送MAX_STREAM_DATA或MAX_DATA帧来通告更大的偏移。但是接收方不能背弃通告的值。也就是说，一旦接收方通告了一个偏移量，它再通告对方一个较小的偏移量则不会产生效果。</p><p>如果发送方违反被通告的连接或流数据量限制，接收方必须用FLOW_CONTROL_ERROR错误（第11节）关闭连接。</p><p>发送方必须忽略任何不提升流量控制限制的MAX_STREAM_DATA或MAX_DATA帧。</p><p>如果发送方用完了流量控制信用分数，它将无法发送新数据并被视为已被阻塞。发送方应该发送TREAM_DATA_BLOCKED或DATA_BLOCKED帧以指示它有要写入的数据但被流控制限制阻止。预计这些帧在常见情况下不经常发送，但它们被认为对调试和监视有用。</p><p>发送方在达到数据限制时应该仅发送一次STREAM_DATA_BLOCKED或DATA_BLOCKED帧。除非确定原始帧丢失，否则发送方不应为相同的数据限制发送多个STREAM_DATA_BLOCKED或DATA_BLOCKED帧。在数据限制增加后，可以发送另一个STREAM_DATA_BLOCKED或DATA_BLOCKED帧。</p><h4 id="流量控制信用分数的增加">4.2 流量控制信用分数的增加</h4><p>本文档将MAX_STREAM_DATA或MAX_DATA帧中通告的时间间隔和字节数量限制留给实现，但提供了一些注意事项。这些帧有助于降低连接开销。因此，经常发送具有小变化的帧是不被鼓励的。同时，如果更新频率较低，则需要更大的增量限制以避免阻塞，因此接收方需要提供更大的缓存资源。因此，在确定通告限制的大小时，<em>在资源维护和开销之间存在折衷。（原文：Thus there is a trade-off between resource commitment and overhead when determining how large a limit is advertised.）</em></p><p>接收方可以使用基于往返时间估计和接收应用消耗数据的速率的自动调整机制来调整通告增加的信用分数的频率和数量，类似于常见的TCP实现。作为优化，仅当存在要发送的其他帧或者对等体被阻止时发送与流控制相关的帧确保流控制不会导致额外的数据包被发送。</p><p>如果发送方用完了流量控制信用分数，它将无法发送新数据并被视为已被阻塞。通常认为最好不要让发送方被阻塞。为避免阻塞发送方，并合理地考虑丢失的可能性，接收方应至少两次往返发送MAX_DATA或MAX_STREAM_DATA帧，然后才能阻塞发送方。</p><p>在发送MAX_STREAM_DATA或MAX_DATA之前，接收方不能等待来自发送方的STREAM_DATA_BLOCKED或DATA_BLOCKED帧，因为这样做意味着发送方将至少在整个往返过程中被阻塞，如果对等方选择不发送STREAM_DATA_BLOCKED或DATA_BLOCKED，则被阻塞时间可能更长。</p><h4 id="处理流取消">4.3 处理流取消</h4><p>端点需要最终就消耗的流量控制信用分数达成一致，以避免超出流量控制限制或死锁。</p><p>在接收到RESET_STREAM帧时，端点将取消对应流的状态计算并忽略到达该流的其他数据。如果RESET_STREAM帧与同一流的流数据重新排序，则接收者对该流上接收的字节数的估计可能低于发送者对发送的数量的估计。因此，两个端点可能无法就计入连接级流量控制的字节数达成一致。</p><p>要解决此问题，RESET_STREAM帧（第19.4节）包括在流上发送的最终数据大小。在接收到RESET_STREAM帧时，接收方明确地知道在RESET_STREAM帧之前在该流上发送了多少字节，并且接收方必须使用流的最终大小来实施连接级流量控制。</p><p>RESET_STREAM会终止流的一个方向。对于双向流，RESET_STREAM对相反方向的数据流没有影响。两个端点必须在未终止方向上继续保持流的流控制状态，直到该方向进入终结状态，或者直到其中一个端点发送CONNECTION_CLOSE。</p><h4 id="流最终大小">4.4 流最终大小</h4><p>最终大小是流消耗的流量控制信用分数。假设流上的每个连续字节都发送一次，最终大小是发送的字节数。更一般地说，这比流上发送的最大字节偏移大一。</p><p>对于重置的流，最终大小在RESET_STREAM帧中显式携带。否则，最终大小是偏移加上标有FIN标志的STREAM帧的长度，或者在传入的单向流的情况下为0。</p><p>当流的接收部分进入“Size Known”或“Reset Recvd”状态时（第3节），端点将知道流的最终大小。</p><p>端点不得在最终大小或超出最终大小的流上发送数据。</p><p>一旦知道了流的最终大小，它就不能再改变。如果收到RESET_STREAM或STREAM帧，指示流的最终大小发生了变化，则端点应该响应FINAL_SIZE_ERROR错误（参见第11节）。接收方应该将最终大小或超出最终大小的数据接收视为FINAL_SIZE_ERROR错误，即使在流关闭后也是如此。生成这些错误不是强制性的，只是因为要求端点生成这些错误也意味着端点需要维持关闭流的最终大小状态，这可能意味着需要维护一些状态。</p><h4 id="控制并发">4.5 控制并发</h4><p>端点限制对等方可以打开的传入流的总数。只有流ID小于<code>max_stream * 4 + initial_stream_id_for_type</code>的流可以被打开。初始限制在传输参数中设置（参见第18.1节），随后使用MAX_STREAMS帧（第19.11节）公布限制。单向和双向流适用于不同的限制。</p><p>端点不得超过其对等端设置的限制。接收流ID超过其发送限制的STREAM帧的端点必须将其视为STREAM_LIMIT_ERROR类型的流错误（第11节）。</p><p>接收方不能违背通告。也就是说，一旦接收器使用MAX_STREAMS帧通告流限制，则通告较小的限制无效。接收方必须忽略任何不增加流限制的MAX_STREAMS帧。</p><p>与流级和连接级流量控制一样，本文档将通过MAX_STREAMS向对等体通告的时间间隔和流数量留给实现。实现可能会选择增加限制，以保持对等体可用的流数量大致一致。</p><p>由于对等端限制而无法打开新流的端点应该发送STREAMS_BLOCKED帧（第19.14节）。该信号被认为对调试很有用。在通告增加信用分数之前，端点不得等待接收此信号，因为这样做意味着对等体将至少在整个往返中被阻塞，并且如果对等体选择不发送STREAMS_BLOCKED帧，则可能持续更长时间。</p><h3 id="连接">5. 连接</h3><p>QUIC的连接建立将版本协商与加密和传输握手相结合，以减少连接建立延迟，如第7节所述。一旦建立，连接可以迁移到任一端点的不同IP或端口，如第9节所述。最后，连接可以由任一端点终止，如第10节所述。</p><h4 id="连接id">5.1 连接ID</h4><p>每个连接都拥有一组连接标识符或连接ID，每个标识符都可以标识连接。连接ID由端点独立选择;每个端点选择其对等方使用的连接ID。</p><p>连接ID的主要功能是确保较低协议层（UDP，IP）的寻址更改不会导致QUIC连接的数据包传递到错误的端点。每个端点使用特定于实现（并且可能是特定于部署）的方法来选择连接ID，该方法将允许具有该连接ID的分组被路由到端点并在接收时由端点识别。</p><p><em>连接ID不得包含外部观察者可以使用的任何信息，防止将它们与同一连接的其他连接ID相关联。作为一个简单的例子，这意味着在同一连接上不得多次发出相同的连接ID。（原文：Connection IDs MUST NOT contain any information that can be used by an external observer to correlate them with other connection IDs for the same connection. As a trivial example, this means the same connection ID MUST NOT be issued more than once on the same connection.）</em></p><p>具有长标头的数据包包括源连接ID和目标连接ID字段。这些字段用于设置新连接的连接ID，有关详细信息，请参阅第7.2节。</p><p>具有短标头的数据包（第17.3节）仅包含目标连接ID，并省略显式长度。期望终结点知道目标连接ID字段的长度。使用基于连接ID路由的负载均衡器的端点可以在固定长度上与负载均衡器达成连接ID，或者就编码方案达成一致。固定部分可以编码显式长度，这允许整个连接ID的长度变化并且仍然可以由负载平衡器使用。</p><p>版本协商（第17.2.1节）数据包回应客户端选择的连接ID，以确保正确路由到客户端并允许客户端验证数据包是否是初始数据包的响应。</p><p>当路由不需要连接ID并且数据包的地址/端口元组足以识别连接时，可以使用零长度连接ID。对等体已选择零长度连接ID的端点必须继续在连接的生存期内使用零长度连接ID，并且绝不能从任何其他本地地址发送数据包。</p><p>当端点请求非零长度连接ID时，需要确保对等体具有连接ID可供选择，从中可以选择发送到端点的数据包。这些连接ID由端点使用NEW_CONNECTION_ID帧提供（第19.15节）。</p><h5 id="发出连接id">5.1.1 发出连接ID</h5><p>每个连接ID都有一个关联的序列号，以帮助对消息进行数据去重。在握手期间，端点发出的初始连接ID在长数据包报头的源连接ID字段（第17.2节）中发送。初始连接ID的序列号为0.如果发送preferred_address传输参数，则提供的连接ID的序列号为1。</p><p>使用NEW_CONNECTION_ID帧将附加连接ID传送给对等体（第19.15节）。每个新发布的连接ID上的序列号必须增加1.客户端在初始数据包中随机选择的连接ID和重试数据包提供的任何连接ID都不会分配序列号，除非服务端选择将它们保留为初始连接ID。</p><p>当端点发出连接ID时，它必须接受在连接期间携带此连接ID的数据包，或者直到其对等体通过RETIRE_CONNECTION_ID帧使连接ID无效（第19.16节）。</p><p>端点应该确保其对等体具有足够数量的可用和未使用的连接ID。虽然每个端点独立选择要发出的连接ID数量，但端点应该提供并维护至少八个连接ID。端点应该通过在对等体退出连接ID时或者当端点接收到具有先前未使用的连接ID的数据包时始终提供新的连接ID来执行此操作。启动迁移并要求非零长度连接ID的端点应该在迁移之前为其对等方提供新的连接ID，否则可能会使对等方关闭连接。</p><h5 id="使用和退出连接id">5.1.2 使用和退出连接ID</h5><p>端点可以在连接期间随时将其用于对等的连接ID更改为另一个可用的连接ID。端点使用连接ID的响应来迁移对等体，有关更多信息，请参见第9.5节。</p><p>端点维护从其对等方接收的一组连接ID，其中任何一个都可以在发送数据包时使用。当端点希望从使用中删除连接ID时，它会向其对等端发送RETIRE_CONNECTION_ID帧。发送RETIRE_CONNECTION_ID帧表示将不再使用连接ID，并请求对等方使用NEW_CONNECTION_ID帧将其替换为新的连接ID。</p><p>如第9.5节所述，每个连接ID必须用于仅从一个本地地址发送的数据包。迁移远离本地地址的端点应该在该地址不再计划使用该地址时退出该地址上使用的所有连接ID。</p><h4 id="将数据包与连接匹配">5.2 将数据包与连接匹配</h4><p>传入的数据包在被接收时分类。数据包可以与现有连接相关联，或者服务端会创建新连接。</p><p>主机尝试将数据包与现有连接相关联。如果数据包具有与现有连接相对应的目标连接ID，则QUIC会相应地处理该数据包。请注意，可以将多个连接ID与连接关联见5.1节。</p><p>如果目标连接ID为零长度且数据包与主机不需要连接ID的连接的地址/端口元组匹配，则QUIC将该数据包作为该连接的一部分进行处理。端点应该拒绝使用与现有连接相同的地址的连接尝试，或者使用非零长度的目标连接ID，以便可以将数据包正确地与连接匹配。</p><p>端点可以为任何无法与现有连接匹配的数据包发送无状态重置（第10.4节）。无状态重置允许对等方更快地识别连接何时变得不可用。</p><p>与现有连接匹配但端点无法去除数据包保护的数据包将被丢弃。</p><p>可以丢弃无数据包保护的无效数据包，例如Initial，Retry或Version Negotiation。如果端点在发现错误之前提交状态更改，则必须生成连接错误。</p><h5 id="客户端数据包处理">5.2.1 客户端数据包处理</h5><p>发送到客户端的有效数据包始终包含与客户端选择的值匹配的目标连接ID。选择接收零长度连接ID的客户端可以使用地址/端口元组来标识连接。与现有连接不匹配的数据包将被丢弃。</p><p>由于数据包重新排序或丢失，客户端可能会收到使用尚未计算的密钥加密的连接数据包。客户端可以丢弃这些数据包，或者可以缓冲它们以预期以后允许它计算密钥的数据包。</p><p>如果客户端收到的数据包具有不受支持的版本，则必须丢弃该数据包。</p><h5 id="服务端包处理">5.2.2 服务端包处理</h5><p>如果服务器收到的数据包具有不受支持的版本，但数据包足够大，无法为服务器支持的任何版本启动新连接，则应该按照第6.1节中的说明发送版本协商数据包。服务器可以对这些数据包进行速率控制，以避免版本协商数据包的风暴。</p><p>不受支持的版本的第一个数据包可以对任何特定于版本的字段使用不同的语义和编码。特别地，不同的数据包保护密钥可以用于不同的版本。不支持特定版本的服务器不太可能解密数据包的有效负载。服务端不应尝试解码或解密来自未知版本的数据包，而是发送版本协商数据包，前提是数据包足够长。</p><p>服务器必须丢弃包含不受支持的版本的其他数据包。</p><p>具有受支持版本或无版本字段的数据包与使用连接ID的连接匹配，或者使用（对于具有零长度连接ID的数据包）地址端口元组进行匹配。如果数据包与现有连接不匹配，则服务器继续执行下面的动作。</p><p>如果数据包是完全符合规范的初始数据包，则服务器继续进行握手（第7节）。这会将服务端提交到客户端选择的版本。</p><p>如果服务器当前没有接受任何新连接，它应该发送一个包含CONNECTION_CLOSE帧的初始数据包，错误代码为SERVER_BUSY。</p><p>如果该数据包是0-RTT数据包，则服务端可以缓冲有限数量的这些分组以等待迟到的初始数据包。在服务端响应之前，客户端被禁止发送握手数据包，因此服务器应该忽略任何此类数据包。</p><p>服务器必须在所有其他情况下丢弃传入的数据包。</p><h4 id="quic连接的生命周期">5.3 QUIC连接的生命周期</h4><blockquote><p>TBD</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对QUIC协议IETF提案：&lt;a href=&quot;https://quicwg.org/base-drafts/draft-ietf-quic-transport.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;draft-ietf-quic-transport-latest&lt;/a&gt;翻译的第二部分。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://quicwg.org/base-drafts/draft-ietf-quic-transport.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;draft-ietf-quic-transport-latest&lt;/a&gt;是在&lt;a href=&quot;https://quicwg.org/base-drafts/draft-ietf-quic-invariants.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;draft-ietf-quic-invariants-latest&lt;/a&gt;基础上定义的第一个版本的QUIC协议，这里描述了QUIC协议的核心，包括一些概念定义与具体的协议行为。&lt;/p&gt;
&lt;p&gt;第二部分翻译内容包括第4，5节。内容包括流量控制与连接等概念。&lt;/p&gt;
    
    </summary>
    
      <category term="network" scheme="https://tiannian.github.io/categories/network/"/>
    
      <category term="quic" scheme="https://tiannian.github.io/categories/network/quic/"/>
    
    
      <category term="QUIC" scheme="https://tiannian.github.io/tags/QUIC/"/>
    
      <category term="translate" scheme="https://tiannian.github.io/tags/translate/"/>
    
      <category term="RFC" scheme="https://tiannian.github.io/tags/RFC/"/>
    
      <category term="Protocol" scheme="https://tiannian.github.io/tags/Protocol/"/>
    
  </entry>
  
  <entry>
    <title>QUIC协议翻译 - draft-ietf-quic-transport-latest Part 1.</title>
    <link href="https://tiannian.github.io/2019/02/13/network/quic/draft-ietf-quic-transport-latest-1/"/>
    <id>https://tiannian.github.io/2019/02/13/network/quic/draft-ietf-quic-transport-latest-1/</id>
    <published>2019-02-13T03:09:28.000Z</published>
    <updated>2019-02-16T14:50:49.295Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对QUIC协议IETF提案：<a href="https://quicwg.org/base-drafts/draft-ietf-quic-transport.html" target="_blank" rel="noopener">draft-ietf-quic-transport-latest</a>翻译的第一部分。</p><p><a href="https://quicwg.org/base-drafts/draft-ietf-quic-transport.html" target="_blank" rel="noopener">draft-ietf-quic-transport-latest</a>是在<a href="https://quicwg.org/base-drafts/draft-ietf-quic-invariants.html" target="_blank" rel="noopener">draft-ietf-quic-invariants-latest</a>基础上定义的第一个版本的QUIC协议，这里描述了QUIC协议的核心，包括一些概念定义与具体的协议行为。</p><p>第一部分翻译内容包括第1，2，3节。内容包括概述与流的概念。</p><h2 id="abstract">Abstract</h2><p>本文档定义了QUIC传输协议的核心。随附文档描述了QUIC的丢失检测和拥塞控制以及使用TLS进行密钥协商。</p><a id="more"></a><h3 id="简介">1. 简介</h3><p>QUIC是一种多路复用且安全的通用传输协议，它具有如下特性：</p><ul><li>流复用</li><li>流和连接级控制</li><li>低延迟连接建立</li><li>连接迁移和弹性的NAT重绑定</li><li>经过加密与认证的包头和负载</li></ul><p>QUIC使用UDP作为基础，以避免需要更改旧版客户端操作系统和中间件。 QUIC验证其所有包头并加密它交换的大多数数据，包括其信令，以避免引起对中间件的依赖。</p><h4 id="文档结构">1.1 文档结构</h4><p>本文档描述了核心QUIC协议，其结构如下。</p><ul><li>流是QUIC提供的基本服务抽象。<ul><li><strong>第2节</strong> 描述了与流相关的核心概念，</li><li><strong>第3节</strong> 提供了流的参考模型，</li><li><strong>第4节</strong> 概述了流量控制的操作。</li></ul></li><li>连接是QUIC端点进行通信的主体。<ul><li><strong>第5节</strong> 描述了流相关的核心概念，</li><li><strong>第6节</strong> 描述了版本协商，</li><li><strong>第7节</strong> 详细描述了建立连接的过程，</li><li><strong>第8节</strong> 明确关键的拒绝服务缓解机制，</li><li><strong>第9节</strong> 描述了端点如何迁移连接到新的网络路径上，</li><li><strong>第10节</strong> 列出了结束已经打开的流的选项，</li><li><strong>第11节</strong> 提供了对错误处理的通用指导</li></ul></li><li>数据包和数据帧是QUIC通讯的基础单元。<ul><li><strong>第12节</strong> 描述了数据包和数据帧相关的概念，</li><li><strong>第13节</strong> 定义了传输，重传，和确认的模型</li><li><strong>第14节</strong> 明确了管理数据包大小的规则</li></ul></li><li>最后，QUIC协议元素的编码细节描述如下：<ul><li><strong>第15节</strong> （版本）</li><li><strong>第16节</strong> （整数编码）</li><li><strong>第17节</strong> （数据包头）</li><li><strong>第18节</strong> （传输参数）</li><li><strong>第19节</strong> （数据帧）</li><li><strong>第18节</strong> （错误）</li></ul></li></ul><p>随附文档描述了QUIC的丢失检测和拥塞控制[QUIC-RECOVERY]，以及使用TLS进行密钥协商[QUIC-TLS]。</p><p>本文档定义了QUIC版本1，它符合[QUIC-INVARIANTS]中的协议不变量。</p><h4 id="公约和定义">1.2 公约和定义</h4><blockquote><p>略</p></blockquote><h4 id="符号约定">1.3 符号约定</h4><p>本文档中的数据包和框架图使用[RFC2360]第3.1节中描述的格式，并附带以下附加约定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[x]: 表示x是可选的</span><br><span class="line">x(A): 表示x有A bit长</span><br><span class="line">x(A/B/C): 表示x有A，B或C bit长</span><br><span class="line">x(i): 表示x使用第16节描述的可变长编码</span><br><span class="line">x(*): 表示x是可变长度的</span><br></pre></td></tr></table></figure><h3 id="流">2. 流</h3><p>QUIC中的流为应用程序提供轻量级，有序的字节流抽象。 从另一个角度来说流是QUIC作为弹性的消息抽象。</p><p>可以通过发送数据来创建流。与流管理相关的过程（结束，取消和流控制）都旨在实现最小的开销。例如，单个STREAM帧可以打开流，携带数据或关闭流。流也可以是长期存在的，并且可以持续整个连接的持续时间。</p><p>流可以由任一端点创建，可以同时发送与其他流不同的数据，并且可以被取消。 QUIC没有提供任何确保不同流之间字节排序的方法。</p><p>QUIC允许任意数量的流同时运行，并且可以在任何流上发送任意数量的数据，受流控制约束（参见第4节）和流限制。</p><h4 id="流类型与识别码">2.1 流类型与识别码</h4><p>流可以是单向的或双向的。单向流在一个方向上传输数据：从流的发起者到对等方。双向流允许数据在两个方向上发送。</p><p>通过数值在连接中标识流，称为流ID。流ID对于流是唯一的。 QUIC端点绝不能重用连接中的流ID。流ID被编码为可变长度整数（参见第16节）。</p><p>流ID的最低有效位（0x1）标识流的发起者。客户端发起的流具有偶数编号的流ID（位设置为0），服务器发起的流具有奇数编号的流ID（位设置为1）。</p><p>流ID的第二个最低有效位（0x2）区分双向流（位设置为0）和单向流（位设置为1）。</p><p>因此，来自流ID的最低有效两位将流识别为四种类型之一，如表1中所总结的。</p><table><thead><tr class="header"><th>掩码</th><th>发起者</th><th>流类型</th></tr></thead><tbody><tr class="odd"><td>0x1</td><td>客户端发起</td><td>双向流</td></tr><tr class="even"><td>0x2</td><td>服务端发起</td><td>双向流</td></tr><tr class="odd"><td>0x3</td><td>客户端发起</td><td>单向流</td></tr><tr class="even"><td>0x4</td><td>服务端发起</td><td>单向流</td></tr></tbody></table><p>在每种类型中，使用数字增加的流ID创建流。不按顺序使用的流ID将会导致该类型的所有具有较低编号的流ID的流也被打开。</p><p>客户端打开的第一个双向流的流ID为0。</p><h4 id="接收和发送数据">2.2 接收和发送数据</h4><p>STREAM帧封装了应用程序发送的数据。端点使用STREAM帧中的Stream ID和Offset字段按顺序放置数据。</p><p>端点必须能够将流数据作为有序字节流传递给应用程序。提供有序的字节流要求端点缓冲任何无序接收的数据，直到宣称流量控制限制。</p><p>QUIC没有特别规定无序传输流数据。但是，实现可以选择提供将数据无序传递到接收应用程序的能力。</p><p>端点可以多次接收相同流偏移的流的数据。已经收到的数据可以被丢弃。如果多次发送，给定偏移量的数据不得改变;端点可以将流中相同偏移量的不同数据的接收视为PROTOCOL_VIOLATION类型的连接错误。</p><p>Streams是一种有序的字节流抽象，QUIC中不存在其他可见的结构。当数据传输，数据包丢失后重传数据或者数据在接收器传送到应用程序时，预计不会保留STREAM帧边界。【TODO】</p><p>端点不得在任何流上发送数据，而不确保它在同级设置的流量控制限制范围内。流量控制在第4节中详细描述。【TODO】</p><h4 id="流优先级">2.3 流优先级</h4><p>如果分配给流的资源被正确地优先化，则流复用可以对应用性能产生显着影响。</p><p>QUIC不提供交换优先级信息的框架。相反，它依赖于从使用QUIC的应用程序接收优先级信息。</p><p>QUIC实现应该提供应用程序可以指示流的相对优先级的方式。在决定将资源专用于哪些流时，实现应该使用应用程序提供的信息。</p><h3 id="流状态">3. 流状态</h3><p>本节按发送或接收组件描述流。描述了两个状态机：一个是使用流传输数据时端点的状态机（第3.1节），一个是使用流接收数据时端点的状态机（第3.2节）。</p><p>单向流直接使用适用的状态机。双向流使用两个状态机。在大多数情况下，无论流是单向还是双向，这些状态机的使用都是相同的。打开流的条件对于双向流来说稍微复杂一些，因为发送侧或接收侧的打开导致流在两个方向上打开。</p><p>端点必须按流ID的递增顺序打开相同类型的流。</p><blockquote><p>备注：这些状态机的信息很大。本文档使用流状态来描述何时以及如何发送不同类型的帧以及在接收到不同类型的帧时预期的反应的规则。虽然这些状态机旨在用于实现QUIC，但这些状态并非旨在约束实现。实现可以定义不同的状态机，只要其行为与实现这些状态的实现一致即可。</p></blockquote><h4 id="发送流状态">3.1 发送流状态</h4><p>图1显示了将数据发送到对等方的流的一部分的状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    o</span><br><span class="line">    | Create Stream (Sending)</span><br><span class="line">    | Peer Creates Bidirectional Stream</span><br><span class="line">    v</span><br><span class="line">+-------+</span><br><span class="line">| Ready | Send RESET_STREAM</span><br><span class="line">|       |-----------------------.</span><br><span class="line">+-------+                       |</span><br><span class="line">    |                           |</span><br><span class="line">    | Send STREAM /             |</span><br><span class="line">    |      STREAM_DATA_BLOCKED  |</span><br><span class="line">    |                           |</span><br><span class="line">    | Peer Creates              |</span><br><span class="line">    |      Bidirectional Stream |</span><br><span class="line">    v                           |</span><br><span class="line">+-------+                       |</span><br><span class="line">| Send  | Send RESET_STREAM     |</span><br><span class="line">|       |----------------------&gt;|</span><br><span class="line">+-------+                       |</span><br><span class="line">    |                           |</span><br><span class="line">    | Send STREAM + FIN         |</span><br><span class="line">    v                           v</span><br><span class="line">+-------+                   +-------+</span><br><span class="line">| Data  | Send RESET_STREAM | Reset |</span><br><span class="line">| Sent  |------------------&gt;| Sent  |</span><br><span class="line">+-------+                   +-------+</span><br><span class="line">    |                           |</span><br><span class="line">    | Recv All ACKs             | Recv ACK</span><br><span class="line">    v                           v</span><br><span class="line">+-------+                   +-------+</span><br><span class="line">| Data  |                   | Reset |</span><br><span class="line">| Recvd |                   | Recvd |</span><br><span class="line">+-------+                   +-------+</span><br></pre></td></tr></table></figure><p>端点启动的流的发送部分（客户端类型0和2，服务器类型1和3）由应用程序打开。 <code>Ready</code>状态表示新创建的流，该流能够接受来自应用程序的数据。可以在此状态下缓冲流数据以准备发送。</p><p>发送第一个STREAM或STREAM_DATA_BLOCKED帧会导致流的发送部分进入<code>Send</code>状态。实现可以选择直到它发送第一帧并进入该状态时再将流ID分配给流，这可以允许更好的流优先级。</p><p>由对等方发起的双向流的发送部分（服务器类型0，客户端类型1）进入<code>Ready</code>状态时，如果接收部分进入<code>Recv</code>状态则立即转换到<code>Send</code>状态（第3.2节）。</p><p>在<code>Send</code>状态中，端点通过STEAM帧发送（在必要时重新发送 ）流数据。端点遵守其对等方设置的流量控制限制，并继续接受和处理MAX_STREAM_DATA帧。如果它被流量控制阻塞通过流或者连接发送数据，则<code>Send</code>状态的端点会生成STREAM_DATA_BLOCKED帧。</p><p>在应用程序指示已发送所有流数据并且发送包含FIN位的STREAM帧之后，流的发送部分进入<code>Data Sent</code>状态。从该状态开始，端点仅在必要时重传流数据。端点不需要检查流控制限制，也不需要为此状态的流发送STREAM_DATA_BLOCKED帧。可以接收MAX_STREAM_DATA帧，直到对等体接收到最终流偏移。端点可以安全地忽略它从对等端接收到的处于此状态的流的任何MAX_STREAM_DATA帧。</p><p>一旦成功确认了所有流数据，流的发送部分就进入<code>Data Recvd</code>状态，这是一种结束状态。</p><p>从任何<code>Ready</code>，<code>Send</code>或<code>Data Sent</code>状态，应用程序可以发信号通知它希望放弃流数据的传输。或者，端点可能从其对等端接收STOP_SENDING帧。在任何一种情况下，端点都会发送RESET_STREAM帧，这会导致流进入<code>Reset Sent</code>状态。</p><p>端点可以发送RESET_STREAM作为提及流的第一帧，这会导致该流的发送部分打开，然后立即转换到<code>Reset Sent</code>状态。</p><p>一旦确认了包含RESET_STREAM的分组，则流的发送部分进入<code>Reset Recvd</code>状态，这是终结状态。</p><h4 id="接收流状态">3.2 接收流状态</h4><p>图2显示了从对等方接收数据的流部分的状态。接收流的一部分的状态仅镜像对等体流的发送部分的一些状态。流的接收部分不跟踪发送部分上无法观察到的状态，例如<code>Ready</code>状态。相反，流的接收部分跟踪向应用程序传送数据，其中一些数据不能被发送者观察到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    o</span><br><span class="line">    | Recv STREAM / STREAM_DATA_BLOCKED / RESET_STREAM</span><br><span class="line">    | Create Bidirectional Stream (Sending)</span><br><span class="line">    | Recv MAX_STREAM_DATA / STOP_SENDING (Bidirectional)</span><br><span class="line">    | Create Higher-Numbered Stream</span><br><span class="line">    v</span><br><span class="line">+-------+</span><br><span class="line">| Recv  | Recv RESET_STREAM</span><br><span class="line">|       |-----------------------.</span><br><span class="line">+-------+                       |</span><br><span class="line">    |                           |</span><br><span class="line">    | Recv STREAM + FIN         |</span><br><span class="line">    v                           |</span><br><span class="line">+-------+                       |</span><br><span class="line">| Size  | Recv RESET_STREAM     |</span><br><span class="line">| Known |----------------------&gt;|</span><br><span class="line">+-------+                       |</span><br><span class="line">    |                           |</span><br><span class="line">    | Recv All Data             |</span><br><span class="line">    v                           v</span><br><span class="line">+-------+ Recv RESET_STREAM +-------+</span><br><span class="line">| Data  |--- (optional) ---&gt;| Reset |</span><br><span class="line">| Recvd |  Recv All Data    | Recvd |</span><br><span class="line">+-------+&lt;-- (optional) ----+-------+</span><br><span class="line">    |                           |</span><br><span class="line">    | App Read All Data         | App Read RST</span><br><span class="line">    v                           v</span><br><span class="line">+-------+                   +-------+</span><br><span class="line">| Data  |                   | Reset |</span><br><span class="line">| Read  |                   | Read  |</span><br><span class="line">+-------+                   +-------+</span><br></pre></td></tr></table></figure><p>当为该流接收到第一个STREAM，STREAM_DATA_BLOCKED或RESET_STREAM时，将创建由对等方发起的流的接收部分（客户端的类型1和3，或服务器的0和2）。对于由对等方发起的双向流，接收流的发送部分的MAX_STREAM_DATA或STOP_SENDING帧也会创建接收部分。流的接收部分的初始状态是<code>Recv</code>。</p><p>当端点发起的双向流的发送部分（客户端类型0，服务器类型1）进入<code>Ready</code>状态时，流的接收部分进入<code>Recv</code>状态。</p><p>当从该流的对等体收到MAX_STREAM_DATA或STOP_SENDING帧时，端点将打开双向流。为未打开的流接收MAX_STREAM_DATA帧表示远程对等体已打开流并提供流控制分数。为未打开的流接收STOP_SENDING帧表示远程对等体不再希望接收此流上的数据。如果数据包丢失或重新排序，则任何一个帧都可能在STREAM或STREAM_DATA_BLOCKED帧之前到达。</p><p>在创建流之前，必须创建具有较低编号的流ID的所有相同类型的流。这可确保流的创建顺序在两个端点上保持一致。</p><p>在“Recv”状态中，端点接收STREAM和STREAM_DATA_BLOCKED帧。传入的数据被缓冲，可以重新组合成正确的顺序以便传送到应用程序。当应用程序使用数据并且缓冲区空间可用时，端点发送MAX_STREAM_DATA帧以允许对等方发送更多数据。</p><p>当接收到具有FIN位的STREAM帧时，流的最终大小是已知的（参见第4.4节）。然后，流的接收部分进入<code>Size Known</code>状态。在此状态下，端点不再需要发送MAX_STREAM_DATA帧，它只接收流数据的任何重传。</p><p>一旦接收到流的所有数据，接收部分就进入<code>Data Recvd</code>状态。这可能是由于接收到导致转换为<code>Size Known</code>的相同STREAM帧而发生的。在此状态下，端点具有所有流数据。可以丢弃它为流接收的任何STREAM或STREAM_DATA_BLOCKED帧。</p><p><code>Data Recvd</code>状态持续存在，直到流数据已传送到应用程序。一旦传送了流数据，流就进入<code>Data Read</code>状态，这是一种终结状态。</p><p>在<code>Recv</code>或<code>Size Known</code>状态下接收到RESET_STREAM帧会使流进入<code>Reset Recvd</code>状态。这可能导致流数据传递到应用程序中断。</p><p>当流处于<code>Data Recvd</code>状态接收到RESET_STREAM时，端点可能接收到所有流数据。类似地，在接收RESET_STREAM帧之后剩余的流数据可能到达（<code>Reset Recvd</code>状态）。一个实现可以自由选择管理这种情况。发送RESET_STREAM意味着端点无法保证流数据的传递。但是，如果收到RESET_STREAM，则不要求不传送流数据。实现可以中断流数据的传送，丢弃未使用的任何数据，并立即发出RESET_STREAM的接收信号。或者，如果流数据被完全接收并且缓冲以供应用程序读取，则可以抑制或保留RESET_STREAM信号。在后一种情况下，流的接收部分从<code>Reset Recvd</code>转换为<code>Data Recvd</code>。</p><p>一旦应用程序已经被传送指示流被重置的信号，流的接收部分就转换到<code>Reset Recvd</code>状态，这是终结状态。</p><h4 id="允许的帧类型">3.3 允许的帧类型</h4><p>流的发送方只发送三种帧类型，这些类型会影响发送方或接收方的流状态：STREAM（第19.8节），STREAM_DATA_BLOCKED（第19.13节）和RESET_STREAM（第19.4节）。</p><p>发送方不得从终结状态（<code>Data Recvd</code>或<code>Reset Recvd</code>）发送任何这些帧。发送者在发送RESET_STREAM后不得发送STREAM或STREAM_DATA_BLOCKED。也就是说，在终结状态和<code>Reset Sent</code>状态下。接收器可以在任何状态下接收这三个帧中的任何一个，因为可能延迟传送携带它们的分组。</p><p>流的接收器发送MAX_STREAM_DATA（第19.10节）和STOP_SENDING帧（第19.5节）。</p><p>接收器仅发送处于<code>Recv</code>状态的MAX_STREAM_DATA。接收器可以在没有收到RESET_STREAM帧的任何状态下发送STOP_SENDING;这是除<code>Reset Recvd</code>或<code>Reset Read</code>以外的状态。但是，在<code>Data Recvd</code>状态下发送STOP_SENDING帧几乎没有价值，因为已收到所有流数据。由于数据包的延迟传送，发送方可以在任何状态下接收这两个帧中的任何一个。</p><h4 id="双向流状态">3.4 双向流状态</h4><p>双向流由发送和接收部分组成。实现可以将双向流的状态表示为发送和接收流状态的组合。当发送或接收部分处于非终结状态时，最简单的模型将流呈现为<code>open</code>，而当发送和接收流都处于终结状态时，流呈现为<code>closed</code>。</p><p>表2显示了与HTTP/2 中的流状态松散对应的双向流状态的复杂映射。这表明发送或接收部分流的多个状态被映射到相同的复合状态。请注意，这只是这种映射的一种可能性;此映射要求在转换到<code>closed</code>或<code>half-closed</code>状态之前确认数据。</p><table><thead><tr class="header"><th>发送部分</th><th>接收部分</th><th>复合状态</th></tr></thead><tbody><tr class="odd"><td>No Stream/Ready</td><td>No Stream/Recv *1</td><td>idle</td></tr><tr class="even"><td>Ready/Send/Data Sent</td><td>Recv/Size Known</td><td>open</td></tr><tr class="odd"><td>Ready/Send/Data Sent</td><td>Data Recvd/Data Read</td><td>half-closed (remote)</td></tr><tr class="even"><td>Ready/Send/Data Sent</td><td>Reset Recvd/Reset Read</td><td>half-closed (remote)</td></tr><tr class="odd"><td>Data Recvd</td><td>Recv/Size Known</td><td>half-closed (local)</td></tr><tr class="even"><td>Reset Sent/Reset Recvd</td><td>Recv/Size Known</td><td>half-closed (local)</td></tr><tr class="odd"><td>Reset Sent/Reset Recvd</td><td>Data Recvd/Data Read</td><td>closed</td></tr><tr class="even"><td>Reset Sent/Reset Recvd</td><td>Reset Recvd/Reset Read</td><td>closed</td></tr><tr class="odd"><td>Data Recvd</td><td>Data Recvd/Data Read</td><td>closed</td></tr><tr class="even"><td>Data Recvd</td><td>Reset Recvd/Reset Read</td><td>closed</td></tr></tbody></table><blockquote><p>备注 (*1)：如果尚未创建流，则该流被认为是<code>idle</code>，或者如果流的接收部分处于“Recv”状态而尚未接收到任何帧，则该流被认为是<code>idle</code>。</p></blockquote><h4 id="询问状态过渡">3.5 询问状态过渡</h4><p>如果端点不再对它在流上接收的数据感兴趣，它可以发送一个STOP_SENDING帧来标识该流，以提示在相反方向关闭流。这通常表示接收应用程序不再读取它从流中接收的数据，但不保证将忽略传入的数据。</p><p>发送STOP_SENDING后收到的STREAM帧仍计入连接和流量控制，即使这些帧在接收时将被丢弃。</p><p>STOP_SENDING帧请求接收端点发送RESET_STREAM帧。如果流处于就绪或发送状态，则接收STOP_SENDING帧的端点必须发送RESET_STREAM帧。如果流处于数据发送状态并且任何未完成的数据被声明丢失，则端点应该发送RESET_STREAM帧代替重传。</p><p>端点应该将错误代码从STOP_SENDING帧复制到它发送的RESET_STREAM帧，但是可以使用任何应用程序错误代码。发送STOP_SENDING帧的端点可以忽略它接收的任何RESET_STREAM帧中携带的错误代码。</p><p>如果在已经处于<code>Data Sent</code>状态的流上接收到STOP_SENDING帧，则希望停止在该流上重传先前发送的STREAM帧的端点必须首先发送RESET_STREAM帧。</p><p>STOP_SENDING应该仅针对未被对等方重置的流发送。 STOP_SENDING对于<code>Recv</code>或<code>Size Known</code>状态的流最有用。</p><p>如果包含先前STOP_SENDING的数据包丢失，则端点应发送另一个STOP_SENDING帧。但是，一旦为流接收到所有流数据或RESET_STREAM帧（即，流处于<code>Recv</code>或<code>Size Known</code>以外的任何状态）发送STOP_SENDING帧是不必要的。</p><p>希望终止双向流的两个方向的端点可以通过发送RESET_STREAM来终止一个方向，并且它可以通过发送STOP_SENDING帧来鼓励在相反方向上的快速终止。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对QUIC协议IETF提案：&lt;a href=&quot;https://quicwg.org/base-drafts/draft-ietf-quic-transport.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;draft-ietf-quic-transport-latest&lt;/a&gt;翻译的第一部分。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://quicwg.org/base-drafts/draft-ietf-quic-transport.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;draft-ietf-quic-transport-latest&lt;/a&gt;是在&lt;a href=&quot;https://quicwg.org/base-drafts/draft-ietf-quic-invariants.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;draft-ietf-quic-invariants-latest&lt;/a&gt;基础上定义的第一个版本的QUIC协议，这里描述了QUIC协议的核心，包括一些概念定义与具体的协议行为。&lt;/p&gt;
&lt;p&gt;第一部分翻译内容包括第1，2，3节。内容包括概述与流的概念。&lt;/p&gt;
&lt;h2 id=&quot;abstract&quot;&gt;Abstract&lt;/h2&gt;
&lt;p&gt;本文档定义了QUIC传输协议的核心。随附文档描述了QUIC的丢失检测和拥塞控制以及使用TLS进行密钥协商。&lt;/p&gt;
    
    </summary>
    
      <category term="network" scheme="https://tiannian.github.io/categories/network/"/>
    
      <category term="quic" scheme="https://tiannian.github.io/categories/network/quic/"/>
    
    
      <category term="QUIC" scheme="https://tiannian.github.io/tags/QUIC/"/>
    
      <category term="translate" scheme="https://tiannian.github.io/tags/translate/"/>
    
      <category term="RFC" scheme="https://tiannian.github.io/tags/RFC/"/>
    
      <category term="Protocol" scheme="https://tiannian.github.io/tags/Protocol/"/>
    
  </entry>
  
  <entry>
    <title>QUIC协议翻译 - draft-ietf-quic-invariants-latest</title>
    <link href="https://tiannian.github.io/2019/02/13/network/quic/draft-ietf-quic-invariants-latest/"/>
    <id>https://tiannian.github.io/2019/02/13/network/quic/draft-ietf-quic-invariants-latest/</id>
    <published>2019-02-13T03:01:12.000Z</published>
    <updated>2019-02-15T12:19:14.612Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对QUIC协议IETF提案：<a href="https://quicwg.org/base-drafts/draft-ietf-quic-invariants.html" target="_blank" rel="noopener">draft-ietf-quic-invariants-latest</a>的翻译。</p><p><a href="https://quicwg.org/base-drafts/draft-ietf-quic-invariants.html" target="_blank" rel="noopener">draft-ietf-quic-invariants-latest</a>是IETF的QUIC提案中的第一部分，包含了基础的QUIC的数据包形式，定义了QUIC各个版本之间不应该发生变化的内容，明确了什么样的协议属于QUIC协议，并为不同版本的QUIC协议的兼容提供支持。</p><h2 id="abstract">Abstract</h2><p>本文档定义了QUIC传输协议的属性，随着协议的新版本的开发，这些属性随时间保持不变。</p><a id="more"></a><h3 id="简介">1. 简介</h3><p>除了提供安全的多路传输外，QUIC <a href="https://quicwg.org/base-drafts/draft-ietf-quic-invariants.html#QUIC-TRANSPORT" target="_blank" rel="noopener">[QUIC-TRANSPORT]</a>还包括协商版本的能力。这允许协议随着时间的推移而改变以响应新的要求。协议的许多特征将在不同版本之间变化。</p><p>本文档描述了QUIC的子集，旨在在开发和部署新版本时保持稳定。所有这些不变特性都是与IP版本无关的。</p><p>本文档的主要目标是确保可以部署新版本的QUIC。本文档记录了协议中无法变更的属性，旨在保留更改协议其他任何部分的能力。因此，除非在本文件中具体描述的内容，协议的任何方面都可以在不同版本之间发生改变。</p><p>附录A是根据QUIC版本1的知识可能做出的一些不正确假设的非详尽列表;这些不适用于每个版本的QUIC。</p><h3 id="公约和定义">2. 公约和定义</h3><blockquote><p>略</p></blockquote><h3 id="quic的极其抽象的描述">3. QUIC的极其抽象的描述</h3><p>QUIC是两个端点之间面向连接的协议。这些端点交换UDP数据报。UDP数据报中包含QUIC数据包。 QUIC端点使用QUIC数据包建立QUIC连接，这是这些端点之间的共享的协议状态。</p><h3 id="quic数据包头">4. QUIC数据包头</h3><p>QUIC数据包是QUIC端点交换的UDP数据报的内容。本文档描述了这些数据报的具体内容。</p><p>QUIC定义了两种类型的包头：长和短。长包头的第一个字节的最高有效标志位被置1，短包头的该位置0。</p><p>除了此处描述的值之外，QUIC数据包的有效负载是特定于版本的并且具有任意长度。</p><h4 id="长包头">4.1 长包头</h4><p>长包头采用图1中描述的形式。具有特定于版本的语义的位标记为X.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+</span><br><span class="line">|1|X X X X X X X|</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                         Version (32)                          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|DCIL(4)|SCIL(4)|</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|               Destination Connection ID (0/32..144)         ...</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                 Source Connection ID (0/32..144)            ...</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X  ...</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>具有长报头的QUIC数据包将第一个字节的高位设置为1.该字节中的所有其他位都是特定于版本的。</p><p>接下来的四个字节包括一个32位版本字段（参见第4.4节）。</p><p>下一个字节包含后面两个连接ID（参见第4.3节）的字节长度。每个ID的长度编码为4位无符号整数。目标连接ID（DCIL）的长度占用字节的高位，源连接ID（SCIL）的长度占用字节的低位。编码长度为0表示连接ID的长度也为0字节。非零编码长度增加3以获得连接ID的全长;因此，最终值为0或长度为4到18个字节（包括端点）。例如，值为0xe0的字节描述17字节的目标连接ID和零字节的源连接ID。</p><p>连接ID长度后跟两个连接ID。分别是接收者相关联的连接ID（目的地连接ID）与发送者相关联的连接ID（源连接ID）。</p><p>数据包的其余部分包含特定于版本的内容。</p><h4 id="短包头">4.2 短包头</h4><p>短包头采用图2中描述的形式。具有特定于版本的语义的位标记为X.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+</span><br><span class="line">|0|X X X X X X X|</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                 Destination Connection ID (*)               ...</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X  ...</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>具有短报头的QUIC数据包将第一个字节的高位设置为0。</p><p>具有短报头的QUIC分组包括目的地连接ID。短标头不包括“连接ID长度”，“源连接ID”或“版本”字段。</p><p>数据包的其余部分具有特定于版本的语义。</p><h4 id="连接id">4.3 连接ID</h4><p>连接ID是任意长度的不透明字段。</p><p>连接ID的主要功能是确保较低协议层（UDP，IP和以下）的寻址更改不会导致QUIC连接的数据包传递到错误的端点。端点和支持它们的中介使用连接ID来确保每个QUIC数据包都可以传递到端点的正确实例。在端点处，连接ID用于标识数据包所针对的QUIC连接。</p><p>每个端点使用特定于版本的方法选择连接ID。相同QUIC连接的数据包可能使用不同的连接ID值。</p><h4 id="版本">4.4 版本</h4><p>QUIC版本使用32位整数标识，以网络字节顺序编码。版本0保留用于版本协商（参见第5节）。所有其他版本号都可能有效。</p><p>本文档中描述的属性适用于所有版本的QUIC。不符合本文档中描述的属性的协议不是QUIC。未来的文档可能会描述适用于特定QUIC版本或一系列QUIC版本的其他属性。</p><h3 id="版本协商">5. 版本协商</h3><p>QUIC端点接收具有长报头的数据包及其不理解或不支持的版本时，可能会发送版本协商数据包作为响应。具有短标头的数据包不会触发版本协商。</p><p>版本协商数据包设置第一个字节的高位，因此它符合第4.1节中定义的具有长标头的数据包的格式。 Version Negotiation数据包可由Version字段识别，该字段设置为0x00000000。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+</span><br><span class="line">|1|X X X X X X X|</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                       Version (32) = 0                        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|DCIL(4)|SCIL(4)|</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|               Destination Connection ID (0/32..144)         ...</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                 Source Connection ID (0/32..144)            ...</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Supported Version 1 (32)                   |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                   [Supported Version 2 (32)]                  |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">                               ...</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                   [Supported Version N (32)]                  |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>Version Negotiation数据包包含一个Supported Version字段列表，每个字段标识发送数据包的端点支持的版本。 “支持的版本”字段遵循“版本”字段。版本协商数据包不包含其他字段。端点必须忽略不包含支持的版本字段或截断的支持版本的数据包。</p><p>版本协商数据包不使用完整性或机密性保护。特定的QUIC版本可能会将数据包作为其连接建立过程的一部分进行身份验证。</p><p>端点必须包含它在目标连接ID字段中接收的数据包的源连接ID字段中的值。源连接ID的值必须从接收数据包的目标连接ID复制，该数据最初由客户端随机选择。回复两个连接ID可以使客户端确信服务器已收到数据包，并且版本协商数据包不是由路径外攻击者生成的。</p><p>接收版本协商数据包的端点可能会更改它决定用于后续数据包的版本。端点更改QUIC版本的条件取决于它选择的QUIC版本。</p><p>有关如何支持QUIC版本1的端点生成和使用版本协商数据包的详细说明，请参见[QUIC-TRANSPORT]。</p><h3 id="安全和隐私考量">6.安全和隐私考量</h3><p>中间件可能使用特定版本的QUIC的特征，并假设当其他版本的QUIC表现出相似的特征时，表达相同的底层语义。可能有许多这样的特征（见附录A）。已经做出一些努力来消除或掩盖QUIC版本1中的一些可观察特征，但其中许多仍然存在。其他QUIC版本可能会做出不同的设计决策，因此表现出不同的特征。</p><p>QUIC版本号不会出现在所有QUIC数据包中，这意味着可以根据特定于版本的特征从流中可靠地提取信息，这要求中间件为他们看到的每个连接ID保留状态。</p><p>本文档中描述的Version Negotiation数据包不受完整性保护;它只有适度的防止非路径攻击者插入的保护。 QUIC版本必须定义一种机制来验证它包含的值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对QUIC协议IETF提案：&lt;a href=&quot;https://quicwg.org/base-drafts/draft-ietf-quic-invariants.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;draft-ietf-quic-invariants-latest&lt;/a&gt;的翻译。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://quicwg.org/base-drafts/draft-ietf-quic-invariants.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;draft-ietf-quic-invariants-latest&lt;/a&gt;是IETF的QUIC提案中的第一部分，包含了基础的QUIC的数据包形式，定义了QUIC各个版本之间不应该发生变化的内容，明确了什么样的协议属于QUIC协议，并为不同版本的QUIC协议的兼容提供支持。&lt;/p&gt;
&lt;h2 id=&quot;abstract&quot;&gt;Abstract&lt;/h2&gt;
&lt;p&gt;本文档定义了QUIC传输协议的属性，随着协议的新版本的开发，这些属性随时间保持不变。&lt;/p&gt;
    
    </summary>
    
      <category term="network" scheme="https://tiannian.github.io/categories/network/"/>
    
      <category term="quic" scheme="https://tiannian.github.io/categories/network/quic/"/>
    
    
      <category term="QUIC" scheme="https://tiannian.github.io/tags/QUIC/"/>
    
      <category term="translate" scheme="https://tiannian.github.io/tags/translate/"/>
    
      <category term="RFC" scheme="https://tiannian.github.io/tags/RFC/"/>
    
      <category term="Protocol" scheme="https://tiannian.github.io/tags/Protocol/"/>
    
  </entry>
  
  <entry>
    <title>Strobe protocol framework分析 - Sponge Construction</title>
    <link href="https://tiannian.github.io/2018/12/28/cryptography/Strobe-Sponge/"/>
    <id>https://tiannian.github.io/2018/12/28/cryptography/Strobe-Sponge/</id>
    <published>2018-12-28T08:33:28.000Z</published>
    <updated>2019-02-15T12:19:14.607Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://strobe.sourceforge.io/" target="_blank" rel="noopener">Strobe</a>是一个面向物联网设计的密码学协议框架，目标是为了使加密协议更容易开发，部署，分析，并适用于微型物联网设备。在Strobe的设计中，仅使用了SHA-3中的块函数Keccak-f来对消息进行加密和验证。</p><p>Strobe利用了Keccak的海绵结构（Sponge Construction）来设计。这使得在Strobe的基础上，可以实现包括密码学哈希函数（Cryptographic hash function），消息认证码（Message authentication code）等机制；可以构建对称加密机制，数字签名机制（通过Schnorr Scheme），密钥交换机制（通过DH算法），以及TLS等类似的密码协议。</p><p>在这里将会分析Strobe协议的组成以及其原理，以及如何在Strobe上构建密码协议。</p><p>在分析Strobe协议之前，首先需要明确什么是海绵结构。</p><a id="more"></a><ol type="1"><li><a href="https://tiannian.github.io/2018/12/28/strobe-sponge/">Strobe protocol framework - Sponge Construction</a></li></ol><p>海绵结构（Sponge Construction）是Keccak提出的一种密码学函数。最开始的海绵结构是为构造密码学哈希函数所设计。后来发现通过海绵结构不仅仅适用于具有固定输出长度的密码学哈希函数，同样也适用于具有固定输入长度的流密码机制。</p><p>现有的的哈希函数可以将任意长度的输入映射为固定长度输出（实际上包括SHA2在内的密码学哈希函数也都做不到任意长度的输入，只不过是因为现有的密码学哈希函数可容纳的输入长度上限太大，近似的看作输入长度无限），而海绵结构则是可以将任意长度的输入映射为任意长度的输出。同时它的输出就像是一个随机数预言机（Random Oracle），能够保证输出的随机性。</p><h2 id="cryptographic-sponge-functions">Cryptographic Sponge Functions</h2><p>说了这么多，到底什么是海绵结构呢？</p><p>在密码学中的“海绵”，比较正式的说法应该是密码学海绵函数（Cryptographic Sponge Functions）。这个函数就像是一个海绵一样，能够不断，多次的输入来自外部的数据；同时也能够像挤海绵里的水一样，多次向外输出数据。不同于现实中的海绵，这里的海绵是可以无限的输入数据，也可以无限的输出数据。</p><p>海绵结构是一个简单的迭代的结构。构造一个海绵结构需要两个元素：一个长度为<span class="math inline">\(b\)</span>的状态<span class="math inline">\(S\)</span>（state），在状态上展开迭代过程；以及一个用于操作状态，输入和输入长度都为<span class="math inline">\(b\)</span>的排列函数<span class="math inline">\(f\)</span>。</p><p><img src="f.png"></p><p>实际上这里的函数<span class="math inline">\(f\)</span>是一个纯函数，它接收状态作为传入，返回的是经过它处理后的状态。</p><p>而被传入函数<span class="math inline">\(f\)</span>的状态<span class="math inline">\(S\)</span>被分为两部分，分别是长度为<span class="math inline">\(r\)</span>的公共部分<span class="math inline">\(R\)</span>（rate），和长度为<span class="math inline">\(c\)</span>的私有部分<span class="math inline">\(C\)</span>（capacity）。</p><p><img src="split.png"></p><p>函数<span class="math inline">\(f\)</span>的作用是根据现有的排列（permutation）来迭代产生新的排列。最新的SHA-3算法采用的同样是海绵结构，它采用的排列函数<span class="math inline">\(f\)</span>是<strong>keccak-f[1600]</strong>。其中的1600代表这个函数的输入是1600位，输出同样是1600位。在Strobe中采用的排列函数<span class="math inline">\(f\)</span>是<strong>keccak-f[b]</strong>，其中<span class="math inline">\(b\)</span>是状态<span class="math inline">\(S\)</span>的长度，根据<strong>keccak-f[b]</strong>的设计，<span class="math inline">\(b\)</span>的取值只能是{200,400,800,1600}，长度单位是bit。</p><h2 id="keccak算法">keccak算法</h2><p>在<strong>keccak</strong>的处理过程中被分为两个过程，第一个部分是吸收过程，第二个部分是挤压过程。</p><p>吸收过程就是将输入的数据输入到海绵结构中。输入数据被填充后分割为多个块，每个块的长度与公共部分<span class="math inline">\(R\)</span>的长度相同，之后不断的将这些块与状态<span class="math inline">\(S\)</span>的公共部分<span class="math inline">\(R\)</span>异或，每次异或后都调用排列函数<span class="math inline">\(f\)</span>。</p><p><img src="message.png"></p><p>整个吸收过程是针对每一个输入数据块<span class="math inline">\(m_i\)</span>执行如下算法： <span class="math display">\[(r,c) = f(r \oplus m_i,c)\]</span> 吸收过程可以无限制的迭代下去，从这个角度来说，<strong>keccak</strong>可以吸收无限多的数据到状态中。</p><p>挤压过程就是从海绵结构中获得输出。当我们需要从海绵结构中获得输出时，我们从状态的公共部分读取输出，如果长度不够，那么可以利用<span class="math inline">\(f\)</span>去修改状态，继续读取新的公共部分。这个过程可以不断的继续重复下去，直到读取到足够的输出为止。</p><p><img src="squeeze.png"></p><p>这个过程就是现在SHA-3的算法的执行流程。得到的输出就是哈希值。</p><p>实际上这样的海绵结构不仅仅可以用于哈希函数中。由于输入输出长度可变的特性，当输入较长而输出较短的情况适用于HASH，MAC等场景；而当输入较短，输出较长的情况下适用于对称加密流密码的场景。在流密码的场景中，输入的时密钥与nonce值，输出的是密钥流。</p><h2 id="duplex-construction">Duplex construction</h2><p>事实上，海绵结构不仅仅可以一次吸收，一次挤出，它可以不断的重复吸收挤压的过程。<strong>keccak team</strong>提供了一种可以不断交替输入输出数据的结构，被称为双工结构（Duplex construction）。在这种结构允许我们不断的输入，输出，输入，输出数据。这种结构带来了一种好处：每一时刻的输出会受到之前输入与输出的影响。这样的属性可以实现相同操作的副本一致性（transcript consistency），也就意味着当不同的副本执行相同的操作，各个副本所维护的海绵结构可以保持一致性。</p><p><img src="duplex.png"></p><h2 id="summary">Summary</h2><p>这篇文章简单的介绍了keccak团队设计的海绵结构，以及它的工作方式。虽然keccak成为了最新的SHA-3算法标准，但是并不代表keccak只能当作哈希函数来使用。后续将会继续介绍基于keccak构造的密码学协议框架Strobe。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://strobe.sourceforge.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Strobe&lt;/a&gt;是一个面向物联网设计的密码学协议框架，目标是为了使加密协议更容易开发，部署，分析，并适用于微型物联网设备。在Strobe的设计中，仅使用了SHA-3中的块函数Keccak-f来对消息进行加密和验证。&lt;/p&gt;
&lt;p&gt;Strobe利用了Keccak的海绵结构（Sponge Construction）来设计。这使得在Strobe的基础上，可以实现包括密码学哈希函数（Cryptographic hash function），消息认证码（Message authentication code）等机制；可以构建对称加密机制，数字签名机制（通过Schnorr Scheme），密钥交换机制（通过DH算法），以及TLS等类似的密码协议。&lt;/p&gt;
&lt;p&gt;在这里将会分析Strobe协议的组成以及其原理，以及如何在Strobe上构建密码协议。&lt;/p&gt;
&lt;p&gt;在分析Strobe协议之前，首先需要明确什么是海绵结构。&lt;/p&gt;
    
    </summary>
    
      <category term="cryptography" scheme="https://tiannian.github.io/categories/cryptography/"/>
    
    
      <category term="cryptography" scheme="https://tiannian.github.io/tags/cryptography/"/>
    
      <category term="strobe protocol framework" scheme="https://tiannian.github.io/tags/strobe-protocol-framework/"/>
    
      <category term="keccak" scheme="https://tiannian.github.io/tags/keccak/"/>
    
      <category term="SHA3" scheme="https://tiannian.github.io/tags/SHA3/"/>
    
  </entry>
  
  <entry>
    <title>数字签名机制 - ED25519</title>
    <link href="https://tiannian.github.io/2018/12/28/cryptography/ed25519/"/>
    <id>https://tiannian.github.io/2018/12/28/cryptography/ed25519/</id>
    <published>2018-12-28T02:35:12.000Z</published>
    <updated>2019-02-13T13:11:40.563Z</updated>
    
    <content type="html"><![CDATA[<p>ED25519是一种EdDSA算法，是一种在扭曲爱德华兹曲线（Twisted Edwards curves）上使用Schnorr机制来实现的一种数字签名机制。它具有速度快，密钥较短，安全性高等优点。</p><a id="more"></a><ol type="1"><li><a href="https://tiannian.github.io/2018/12/27/Schnorr-Scheme/">数字签名机制 - Schnorr Scheme</a></li><li><a href="https://tiannian.github.io/2018/12/28/ed25519/">数字签名机制- ED25519</a></li></ol><blockquote><p>本文中所有出现的变量，小写字母表示标量，即一个数字，在这里指整数；大写字母表示离散对数问题中的参数，例如：椭圆曲线中的点。</p></blockquote><p>椭圆曲线密码学（ECC）是基于离散对数问题中的椭圆曲线而设计的。现行的ECC算法多用于替代RSA算法，以提升原始算法的安全性与性能。相比较RSA，ECC的性能较高，密钥长度较短，然而实现难度较大。在ECC算法基础上构建的数字签名算法被称为ECDSA算法，经过NIST批准的曲线有多条，例如secp256r1，secp256k1等。但现有的ECC算法中的曲线被指存在后门。</p><p>EdDSA从某种意义上来说也属于椭圆曲线密码学，不同的是它采用扭曲爱德华兹曲线作为椭圆曲线，同时采用的签名机制也不同于ECDSA算法。EdDSA的重要实现ED25519是Daniel J. Bernstein等人设计的EdDSA算法，采用的曲线参数完全公开，并说明了参数选取的意义，保证曲线中并未内置后门。同时ED25519采用Schnorr机制作为签名的构建方式，使得签名与验证的性能得到了巨大的提升。</p><h2 id="ed25519算法">ED25519算法</h2><p>在现有的方案ED25519种，采用了将参数<span class="math inline">\(R\)</span>，公钥 <span class="math inline">\(Y\)</span>，与消息体 <span class="math inline">\(M\)</span>进行哈希作为随机数 <span class="math inline">\(r_2\)</span>。具体的ED25519公私钥生成与签名验证的方式如下：</p><h4 id="公私钥生成">公私钥生成</h4><p>当前根据ED25519协议中密钥长度 <span class="math inline">\(b\)</span>，被选择为<span class="math inline">\(256\)</span>；生成元为 <span class="math inline">\(G\)</span> ；哈希函数 <span class="math inline">\(H()\)</span>为SHA512；<span class="math inline">\(M\)</span>是被签名的信息；<span class="math inline">\(l\)</span> 是一个质数，满足<span class="math inline">\(lG = 0\)</span>。</p><ol type="1"><li>随机选择一个长度为 <span class="math inline">\(b\)</span> 为的二进制数作为私钥 <span class="math inline">\(a\)</span>。</li><li>对 <span class="math inline">\(a\)</span> 的进行哈希，产生一个长度为 <span class="math inline">\(2b\)</span> 的值为 <span class="math inline">\(h = H(a)\)</span>，其中 <span class="math inline">\(h_0 \ldots h_{b-1}\)</span> 为<span class="math inline">\(x\)</span>，用于产生公钥 ，<span class="math inline">\(h_b \dots h_{2b-1}\)</span> 为随机数 <span class="math inline">\(k\)</span> 。</li><li>将 <span class="math inline">\(x_0, x_1, x_2​\)</span>置<span class="math inline">\(0​\)</span>，<span class="math inline">\(x_{b-1}​\)</span>置0，<span class="math inline">\(x_{b-2}​\)</span>置1。</li><li>计算公钥 <span class="math inline">\(Y = xG\)</span>。</li></ol><p>其中 <span class="math inline">\(a\)</span> 为私钥，<span class="math inline">\(Y\)</span>为公钥。</p><h4 id="签名流程">签名流程</h4><p>进行签名时，需要私钥 <span class="math inline">\(a\)</span>，执行公私钥生成算法，得到公钥 <span class="math inline">\(Y\)</span>，随机数 <span class="math inline">\(k\)</span>。</p><ol type="1"><li>计算随机数 <span class="math inline">\(r = H(k, M)\)</span>。</li><li>计算随机点<span class="math inline">\(R = rG\)</span>。</li><li>计算签名<span class="math inline">\(s = (r + H(R,Y,M)x ) \bmod l\)</span>。</li></ol><p>其中得到的<span class="math inline">\((R,s)\)</span>便是得到的数字签名。</p><p>其中 <span class="math inline">\(s\)</span> 相当于前文所述Schnorr签名方案中的 <span class="math inline">\(s\)</span> ，<span class="math inline">\(r\)</span> 相当于 <span class="math inline">\(r_1\)</span> ，<span class="math inline">\(H(R,Y,M)\)</span>相当于<span class="math inline">\(r_2\)</span>。这里的哈希函数<span class="math inline">\(H()\)</span>便充当了随机数预言机。</p><h4 id="验证流程">验证流程</h4><p>进行验证时，验证者只需要知道公钥 <span class="math inline">\(Y\)</span>，签名<span class="math inline">\((R,s)\)</span>， 消息 <span class="math inline">\(M\)</span> 即可验证签名过程是否正确。</p><ul><li>验证<span class="math inline">\(sG = R + H(R,Y,M)Y\)</span>是否成立，即可验证签名是否正确。</li></ul><p>其中 <span class="math inline">\(s\)</span> 相当于前文所述Schnorr签名方案中验证公式中的 <span class="math inline">\(s\)</span> ，<span class="math inline">\(G\)</span> 为生成元，<span class="math inline">\(H(R,Y,M)\)</span>为 <span class="math inline">\(r_2\)</span> ，其余部分一一对应。</p><h2 id="安全考量">安全考量</h2><p>在ED25519的算法设计中，通过使用密码学哈希函数来代替伪随机数发生器，避免了签名算法的使用者因为采用的随机数生成器不够随机化而产生的安全问题。ED25519的实现除去私钥的生成之外，签名过程已经完全脱离对随机数发生器的依赖，避免了因为随机化问题而导致密钥的泄露与安全性问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ED25519是一种EdDSA算法，是一种在扭曲爱德华兹曲线（Twisted Edwards curves）上使用Schnorr机制来实现的一种数字签名机制。它具有速度快，密钥较短，安全性高等优点。&lt;/p&gt;
    
    </summary>
    
      <category term="cryptography" scheme="https://tiannian.github.io/categories/cryptography/"/>
    
    
      <category term="cryptography" scheme="https://tiannian.github.io/tags/cryptography/"/>
    
      <category term="schnorr scheme" scheme="https://tiannian.github.io/tags/schnorr-scheme/"/>
    
      <category term="digital signature" scheme="https://tiannian.github.io/tags/digital-signature/"/>
    
      <category term="ED25519" scheme="https://tiannian.github.io/tags/ED25519/"/>
    
      <category term="EdDSA" scheme="https://tiannian.github.io/tags/EdDSA/"/>
    
  </entry>
  
  <entry>
    <title>数字签名机制 - Schnorr Scheme</title>
    <link href="https://tiannian.github.io/2018/12/27/cryptography/Schnorr-Scheme/"/>
    <id>https://tiannian.github.io/2018/12/27/cryptography/Schnorr-Scheme/</id>
    <published>2018-12-27T07:25:46.000Z</published>
    <updated>2019-02-13T13:11:40.535Z</updated>
    
    <content type="html"><![CDATA[<p>Schnorr机制是一种基于离散对数难题的知识证明机制，由德国数学家和密码学家Claus-Peter Schnorr在1990年提出。这种知识证明机制具有实现简单，验证速度较快等优点。最开始是为Smart Card这样的资源受限设备而设计。</p><p>经过这些年的发展，在原始的Schnorr机制上实现了多种多样的改进与功能，实现了高性能的数字签名，以及包括环签名，门限签名等复杂签名机制。</p><p>在这里参考Schnorr的论文与其他的参考资料，分析Schnorr机制的原始机制与实现。并分析现在主流的EdDSA的实现ED25519，以及如何在Schnorr机制上建立的复杂签名机制。</p><a id="more"></a><ol type="1"><li><a href="https://tiannian.github.io/2018/12/27/Schnorr-Scheme/">数字签名机制 - Schnorr Scheme</a></li><li><a href="https://tiannian.github.io/2018/12/28/ed25519/">数字签名机制- ED25519</a></li></ol><blockquote><p>本文中所有出现的变量，小写字母表示标量，即一个数字，在这里指整数；大写字母表示离散对数问题中的参数，例如：椭圆曲线中的点。</p></blockquote><h3 id="original-schnorr-scheme">Original Schnorr Scheme</h3><p>原始的Schnorr机制是一个交互式的机制。允许在任何拥有相同生成元（指在离散对数问题中）的协议参与者双方，证明某一方拥有私钥 <span class="math inline">\(x\)</span> 而不需要直接交换它。其中双方都拥有的生成元设为 <span class="math inline">\(G\)</span> ，证明者拥有私钥 <span class="math inline">\(x\)</span> 。验证者从证明者处取得 <span class="math inline">\(Y\)</span> ，其中 <span class="math inline">\(Y = xG\)</span>，<span class="math inline">\(Y\)</span> 即公钥。</p><p>Original Schnorr Signature的协议流程如下：</p><ol type="1"><li>证明者随机选择一个标量 <span class="math inline">\(r_1\)</span>，然后计算出 <span class="math inline">\(R = r_1G\)</span>。并将 <span class="math inline">\(R\)</span> 发送至验证者。</li><li>验证者回应一个随机的标量 <span class="math inline">\(r_2\)</span>。</li><li>证明者回应一个标量<span class="math inline">\(s\)</span>，通过公式 <span class="math inline">\(s = r_1 + r_2x\)</span> 计算。</li></ol><p>因为离散对数问题是困难的，因此验证者不会知道 <span class="math inline">\(x, r_1\)</span>的值，验证者仅知道由 <span class="math inline">\(x, r_1\)</span>计算得到的 <span class="math inline">\(Y, R\)</span>。但是验证者可以通过以下计算来验证<span class="math inline">\(s\)</span>是正确的：</p><ul><li>由于<span class="math inline">\(s = r_1 + r_2x\)</span>，等式两边同时添加相同的生成元可得 <span class="math inline">\(sG = r_1G + r_2xG\)</span>。</li><li>由于<span class="math inline">\(R = r_1G\)</span>，<span class="math inline">\(Y = xG\)</span>，可以化简得到 <span class="math inline">\(sG = R + r_2Y\)</span>。</li></ul><p>其中 <span class="math inline">\(G\)</span> 是生成元，双方都可知，<span class="math inline">\(R, Y, s, r_2\)</span> 验证者都知道，所以验证者可以轻松验证化简过的公式。</p><p>这个过程是零知识的，因为验证者并不能得到私钥 <span class="math inline">\(x\)</span> 的值，却可以通过计算与通讯的方式验证证明者确实拥有私钥 <span class="math inline">\(x\)</span>。</p><h3 id="problem-of-original-schnorr-scheme">Problem of Original Schnorr Scheme</h3><p>然而这样交互式的过程，会导致验证者通过"fork"的方式获得私钥 <span class="math inline">\(x\)</span>。验证者只需要简单的提供两个不同的随机值 <span class="math inline">\(r_2^1, r_2^2\)</span>，并要求证明者计算 <span class="math inline">\(s_1 = r_1 + r_2^1x, s_2 = r_1 + r_2^2x\)</span>，即可计算出<span class="math inline">\(x = (s_1 - s_2)/(r_2^1 - r_2^2)\)</span>。这样一来，这个过程便无法公开的验证，因为一旦两个验证者相互串通，交换自己得到的值，便可以推出私钥<span class="math inline">\(x\)</span>。</p><p>为了解决这个问题，后续将会通过对现有的协议进行Fiat–Shamir变换，使用Random oracles改造这个算法来使Schnorr原始的Schnorr Scheme变成可公开验证的非交互式算法。</p><h3 id="fiatshamir-and-random-oracles">Fiat–Shamir and Random oracles</h3><p>上述原始Schnorr Scheme中存在的私钥泄露问题使得算法无法在公开的环境下使用。通过将原始的交互式协议转变为非交互式协议可以解决这个问题。</p><p>Fiat–Shamir变换是一种利用交互式零知识证明方案创建数字签名的方式。根据Fiat–Shamir变换，我们可以将原始方案中的证明者采用随机数预言机（Random oracle）来代替，利用这样的方式构造数字签名。</p><p>随机数预言机，即随机数函数，是一种针对任意输入得到的输出之间是项目独立切均匀分布的函数。理想的随机数预言机并不存在，在实现中，经常采用密码学哈希函数作为随机数预言机。</p><p>原本的设计中，Schnorr签名是一种交互式协议，需要一个实际存在的验证者与参与者，而根据Fiat-Shamir转换，可以将具体的验证者采用随机数预言机来代替。将验证者替换为随机数预言机后，外部的验证者便无法通过交换 <span class="math inline">\(r_2\)</span>来推出私钥 <span class="math inline">\(x\)</span> ，原本的 <span class="math inline">\(r_2\)</span> 采用随机数预言机产生的随机数来表示。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Schnorr机制是一种基于离散对数难题的知识证明机制，由德国数学家和密码学家Claus-Peter Schnorr在1990年提出。这种知识证明机制具有实现简单，验证速度较快等优点。最开始是为Smart Card这样的资源受限设备而设计。&lt;/p&gt;
&lt;p&gt;经过这些年的发展，在原始的Schnorr机制上实现了多种多样的改进与功能，实现了高性能的数字签名，以及包括环签名，门限签名等复杂签名机制。&lt;/p&gt;
&lt;p&gt;在这里参考Schnorr的论文与其他的参考资料，分析Schnorr机制的原始机制与实现。并分析现在主流的EdDSA的实现ED25519，以及如何在Schnorr机制上建立的复杂签名机制。&lt;/p&gt;
    
    </summary>
    
      <category term="cryptography" scheme="https://tiannian.github.io/categories/cryptography/"/>
    
    
      <category term="cryptography" scheme="https://tiannian.github.io/tags/cryptography/"/>
    
      <category term="schnorr scheme" scheme="https://tiannian.github.io/tags/schnorr-scheme/"/>
    
      <category term="digital signature" scheme="https://tiannian.github.io/tags/digital-signature/"/>
    
      <category term="ED25519" scheme="https://tiannian.github.io/tags/ED25519/"/>
    
      <category term="EdDSA" scheme="https://tiannian.github.io/tags/EdDSA/"/>
    
  </entry>
  
</feed>
