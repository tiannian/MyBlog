<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NianZhe</title>
  
  <subtitle>Nian is made up by Jin and Xin</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tiannian.github.io/"/>
  <updated>2018-12-30T03:04:40.745Z</updated>
  <id>https://tiannian.github.io/</id>
  
  <author>
    <name>Tiannian Du</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Strobe protocol framework分析 - Sponge Construction</title>
    <link href="https://tiannian.github.io/2018/12/28/Strobe-Sponge/"/>
    <id>https://tiannian.github.io/2018/12/28/Strobe-Sponge/</id>
    <published>2018-12-28T08:33:28.000Z</published>
    <updated>2018-12-30T03:04:40.745Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://strobe.sourceforge.io/" target="_blank" rel="noopener">Strobe</a>是一个面向物联网设计的密码学协议框架，目标是为了使加密协议更容易开发，部署，分析，并适用于微型物联网设备。在Strobe的设计中，仅使用了一个块函数Keccak-f来对消息进行加密和验证。</p><p>Strobe利用了Keccak的海绵结构（Sponge Construction）来设计。这使得在Strobe的基础上，可以实现包括密码学哈希函数（Cryptographic hash function），消息认证码（Message authentication code）等机制；可以构建对称加密机制，数字签名机制（通过Schnorr Scheme），密钥交换机制（通过DH算法），以及TLS等类似的密码协议。</p><p>在这里将会分析Strobe协议的组成以及其原理，以及如何在Strobe上构建密码协议。</p><p>在分析Strobe协议之前，首先需要明确什么是海绵结构。</p><a id="more"></a><ol type="1"><li><a href="https://tiannian.github.io/2018/12/28/strobe-sponge/">Strobe protocol framework - Sponge Construction</a></li></ol><p>海绵结构（Sponge Construction）是Keccak提出的一种密码学函数。最开始的海绵结构是为构造密码学哈希函数所设计。后来发现通过海绵结构不仅仅适用于具有固定输出长度的密码学哈希函数，同样也适用于具有固定输入长度的流密码机制。</p><p>现有的的哈希函数可以将任意长度的输入映射为固定长度输出（实际上包括SHA2在内的密码学哈希函数也都做不到任意长度的输入，只不过是因为现有的密码学哈希函数可容纳的输入长度上限太大，近似的看作输入长度无限），而海绵结构则是可以将任意长度的输入映射为任意长度的输出。同时它的输出就像是一个随机数预言机（Random Oracle），能够保证输出的随机性。</p><h2 id="cryptographic-sponge-functions">Cryptographic Sponge Functions</h2><p>说了这么多，到底什么是海绵结构呢？</p><p>在密码学中的“海绵”，比较正式的说法应该是密码学海绵函数（Cryptographic Sponge Functions）。这个函数就像是一个海绵一样，能够不断，多次的输入来自外部的数据；同时也能够像挤海绵里的水一样，多次向外输出数据。不同于现实中的海绵，这里的海绵是可以无限的输入数据，也可以无限的输出数据。</p><p>海绵结构是一个简单的迭代的结构。构造一个海绵结构需要两个元素：一个长度为<span class="math inline">\(b\)</span>的状态<span class="math inline">\(S\)</span>（state），在状态上展开迭代过程；以及一个用于操作状态，输入和输入长度都为<span class="math inline">\(b\)</span>的排列函数<span class="math inline">\(f\)</span>。</p><p><img src="f.png"></p><p>实际上这里的函数<span class="math inline">\(f\)</span>是一个纯函数，它接收状态作为传入，返回的是经过它处理后的状态。</p><p>而被传入函数<span class="math inline">\(f\)</span>的状态<span class="math inline">\(S\)</span>被分为两部分，分别是长度为<span class="math inline">\(r\)</span>的公共部分<span class="math inline">\(R\)</span>（rate），和长度为<span class="math inline">\(c\)</span>的私有部分<span class="math inline">\(C\)</span>（capacity）。</p><p><img src="split.png"></p><p>函数<span class="math inline">\(f\)</span>的作用是根据现有的排列（permutation）来迭代产生新的排列。最新的SHA-3算法采用的同样是海绵结构，它采用的排列函数<span class="math inline">\(f\)</span>是<strong>keccak-f[1600]</strong>。其中的1600代表这个函数的输入是1600位，输出同样是1600位。在Strobe中采用的排列函数<span class="math inline">\(f\)</span>是<strong>keccak-f[b]</strong>，其中<span class="math inline">\(b\)</span>是状态<span class="math inline">\(S\)</span>的长度，根据<strong>keccak-f[b]</strong>的设计，<span class="math inline">\(b\)</span>的取值只能是{200,400,800,1600}，长度单位是bit。</p><h2 id="keccak算法">keccak算法</h2><p>在<strong>keccak</strong>的处理过程中被分为两个过程，第一个部分是吸收过程，第二个部分是挤压过程。</p><p>吸收过程就是将输入的数据输入到海绵结构中。输入数据被填充后分割为多个块，每个块的长度与公共部分<span class="math inline">\(R\)</span>的长度相同，之后不断的将这些块与状态<span class="math inline">\(S\)</span>的公共部分<span class="math inline">\(R\)</span>异或，每次异或后都调用排列函数<span class="math inline">\(f\)</span>。</p><p><img src="message.png"></p><p>整个吸收过程是针对每一个输入数据块<span class="math inline">\(m_i\)</span>执行如下算法： <span class="math display">\[(r,c) = f(r \oplus m_i,c)\]</span> 吸收过程可以无限制的迭代下去，从这个角度来说，<strong>keccak</strong>可以吸收无限多的数据到状态中。</p><p>挤压过程就是从海绵结构中获得输出。当我们需要从海绵结构中获得输出时，我们从状态的公共部分读取输出，如果长度不够，那么可以利用<span class="math inline">\(f\)</span>去修改状态，继续读取新的公共部分。这个过程可以不断的继续重复下去，直到读取到足够的输出为止。</p><p><img src="squeeze.png"></p><p>这个过程就是现在SHA-3的算法的执行流程。得到的输出就是哈希值。</p><p>实际上这样的海绵结构不仅仅可以用于哈希函数中。由于输入输出长度可变的特性，当输入较长而输出较短的情况适用于HASH，MAC等场景；而当输入较短，输出较长的情况下适用于对称加密流密码的场景。在流密码的场景中，输入的时密钥与nonce值，输出的是密钥流。</p><h2 id="duplex-construction">Duplex construction</h2><p>事实上，海绵结构不仅仅可以一次吸收，一次挤出，它可以不断的重复吸收挤压的过程。<strong>keccak team</strong>提供了一种可以不断交替输入输出数据的结构，被称为双工结构（Duplex construction）。在这种结构允许我们不断的输入，输出，输入，输出数据。这种结构带来了一种好处：每一时刻的输出会受到之前输入与输出的影响。这样的属性可以实现相同操作的副本一致性（transcript consistency）。</p><p><img src="duplex.png"></p><h2 id="summary">Summary</h2><p>这篇文章简单的介绍了keccak团队设计的海绵结构，以及它的工作方式。虽然keccak成为了最新的SHA-3算法标准，但是并不代表keccak只能当作哈希函数来使用。后续将会继续介绍基于keccak构造的密码学协议框架Strobe。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://strobe.sourceforge.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Strobe&lt;/a&gt;是一个面向物联网设计的密码学协议框架，目标是为了使加密协议更容易开发，部署，分析，并适用于微型物联网设备。在Strobe的设计中，仅使用了一个块函数Keccak-f来对消息进行加密和验证。&lt;/p&gt;
&lt;p&gt;Strobe利用了Keccak的海绵结构（Sponge Construction）来设计。这使得在Strobe的基础上，可以实现包括密码学哈希函数（Cryptographic hash function），消息认证码（Message authentication code）等机制；可以构建对称加密机制，数字签名机制（通过Schnorr Scheme），密钥交换机制（通过DH算法），以及TLS等类似的密码协议。&lt;/p&gt;
&lt;p&gt;在这里将会分析Strobe协议的组成以及其原理，以及如何在Strobe上构建密码协议。&lt;/p&gt;
&lt;p&gt;在分析Strobe协议之前，首先需要明确什么是海绵结构。&lt;/p&gt;
    
    </summary>
    
    
      <category term="cryptography" scheme="https://tiannian.github.io/tags/cryptography/"/>
    
      <category term="strobe protocol framework" scheme="https://tiannian.github.io/tags/strobe-protocol-framework/"/>
    
      <category term="keccak" scheme="https://tiannian.github.io/tags/keccak/"/>
    
  </entry>
  
  <entry>
    <title>数字签名机制 - ED25519</title>
    <link href="https://tiannian.github.io/2018/12/28/ed25519/"/>
    <id>https://tiannian.github.io/2018/12/28/ed25519/</id>
    <published>2018-12-28T02:35:12.000Z</published>
    <updated>2018-12-30T03:04:40.759Z</updated>
    
    <content type="html"><![CDATA[<p>ED25519是一种EdDSA算法，是一种在扭曲爱德华兹曲线（Twisted Edwards curves）上使用Schnorr机制来实现的一种数字签名机制。它具有速度快，密钥较短，安全性高等优点。</p><a id="more"></a><ol type="1"><li><a href="https://tiannian.github.io/2018/12/27/Schnorr-Scheme/">数字签名机制 - Schnorr Scheme</a></li><li><a href="https://tiannian.github.io/2018/12/28/ed25519/">数字签名机制- ED25519</a></li></ol><blockquote><p>本文中所有出现的变量，小写字母表示标量，即一个数字，在这里指整数；大写字母表示离散对数问题中的参数，例如：椭圆曲线中的点。</p></blockquote><p>椭圆曲线密码学（ECC）是基于离散对数问题中的椭圆曲线而设计的。现行的ECC算法多用于替代RSA算法，以提升原始算法的安全性与性能。相比较RSA，ECC的性能较高，密钥长度较短，然而实现难度较大。在ECC算法基础上构建的数字签名算法被称为ECDSA算法，经过NIST批准的曲线有多条，例如secp256r1，secp256k1等。但现有的ECC算法中的曲线被指存在后门。</p><p>EdDSA从某种意义上来说也属于椭圆曲线密码学，不同的是它采用扭曲爱德华兹曲线作为椭圆曲线，同时采用的签名机制也不同于ECDSA算法。EdDSA的重要实现ED25519是Daniel J. Bernstein等人设计的EdDSA算法，采用的曲线参数完全公开，并说明了参数选取的意义，保证曲线中并未内置后门。同时ED25519采用Schnorr机制作为签名的构建方式，使得签名与验证的性能得到了巨大的提升。</p><h2 id="ed25519算法">ED25519算法</h2><p>在现有的方案ED25519种，采用了将参数<span class="math inline">\(R\)</span>，公钥 <span class="math inline">\(Y\)</span>，与消息体 <span class="math inline">\(M\)</span>进行哈希作为随机数 <span class="math inline">\(r_2\)</span>。具体的ED25519公私钥生成与签名验证的方式如下：</p><h4 id="公私钥生成">公私钥生成</h4><p>当前根据ED25519协议中密钥长度 <span class="math inline">\(b\)</span>，被选择为<span class="math inline">\(256\)</span>；生成元为 <span class="math inline">\(G\)</span> ；哈希函数 <span class="math inline">\(H()\)</span>为SHA512；<span class="math inline">\(M\)</span>是被签名的信息；<span class="math inline">\(l\)</span> 是一个质数，满足<span class="math inline">\(lG = 0\)</span>。</p><ol type="1"><li>随机选择一个长度为 <span class="math inline">\(b\)</span> 为的二进制数作为私钥 <span class="math inline">\(a\)</span>。</li><li>对 <span class="math inline">\(a\)</span> 的进行哈希，产生一个长度为 <span class="math inline">\(2b\)</span> 的值为 <span class="math inline">\(h = H(a)\)</span>，其中 <span class="math inline">\(h_0 \ldots h_{b-1}\)</span> 为<span class="math inline">\(x\)</span>，用于产生公钥 ，<span class="math inline">\(h_b \dots h_{2b-1}\)</span> 为随机数 <span class="math inline">\(k\)</span> 。</li><li>将 <span class="math inline">\(x_0, x_1, x_2​\)</span>置<span class="math inline">\(0​\)</span>，<span class="math inline">\(x_{b-1}​\)</span>置0，<span class="math inline">\(x_{b-2}​\)</span>置1。</li><li>计算公钥 <span class="math inline">\(Y = xG\)</span>。</li></ol><p>其中 <span class="math inline">\(a\)</span> 为私钥，<span class="math inline">\(Y\)</span>为公钥。</p><h4 id="签名流程">签名流程</h4><p>进行签名时，需要私钥 <span class="math inline">\(a\)</span>，执行公私钥生成算法，得到公钥 <span class="math inline">\(Y\)</span>，随机数 <span class="math inline">\(k\)</span>。</p><ol type="1"><li>计算随机数 <span class="math inline">\(r = H(k, M)\)</span>。</li><li>计算随机点<span class="math inline">\(R = rG\)</span>。</li><li>计算签名<span class="math inline">\(s = (r + H(R,Y,M)x ) \bmod l\)</span>。</li></ol><p>其中得到的<span class="math inline">\((R,s)\)</span>便是得到的数字签名。</p><p>其中 <span class="math inline">\(s\)</span> 相当于前文所述Schnorr签名方案中的 <span class="math inline">\(s\)</span> ，<span class="math inline">\(r\)</span> 相当于 <span class="math inline">\(r_1\)</span> ，<span class="math inline">\(H(R,Y,M)\)</span>相当于<span class="math inline">\(r_2\)</span>。这里的哈希函数<span class="math inline">\(H()\)</span>便充当了随机数预言机。</p><h4 id="验证流程">验证流程</h4><p>进行验证时，验证者只需要知道公钥 <span class="math inline">\(Y\)</span>，签名<span class="math inline">\((R,s)\)</span>， 消息 <span class="math inline">\(M\)</span> 即可验证签名过程是否正确。</p><ul><li>验证<span class="math inline">\(sG = R + H(R,Y,M)Y\)</span>是否成立，即可验证签名是否正确。</li></ul><p>其中 <span class="math inline">\(s\)</span> 相当于前文所述Schnorr签名方案中验证公式中的 <span class="math inline">\(s\)</span> ，<span class="math inline">\(G\)</span> 为生成元，<span class="math inline">\(H(R,Y,M)\)</span>为 <span class="math inline">\(r_2\)</span> ，其余部分一一对应。</p><h2 id="安全考量">安全考量</h2><p>在ED25519的算法设计中，通过使用密码学哈希函数来代替伪随机数发生器，避免了签名算法的使用者因为采用的随机数生成器不够随机化而产生的安全问题。ED25519的实现除去私钥的生成之外，签名过程已经完全脱离对随机数发生器的依赖，避免了因为随机化问题而导致密钥的泄露与安全性问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ED25519是一种EdDSA算法，是一种在扭曲爱德华兹曲线（Twisted Edwards curves）上使用Schnorr机制来实现的一种数字签名机制。它具有速度快，密钥较短，安全性高等优点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="cryptography" scheme="https://tiannian.github.io/tags/cryptography/"/>
    
      <category term="schnorr scheme" scheme="https://tiannian.github.io/tags/schnorr-scheme/"/>
    
      <category term="digital signature" scheme="https://tiannian.github.io/tags/digital-signature/"/>
    
      <category term="ED25519" scheme="https://tiannian.github.io/tags/ED25519/"/>
    
      <category term="EdDSA" scheme="https://tiannian.github.io/tags/EdDSA/"/>
    
  </entry>
  
  <entry>
    <title>数字签名机制 - Schnorr Scheme</title>
    <link href="https://tiannian.github.io/2018/12/27/Schnorr-Scheme/"/>
    <id>https://tiannian.github.io/2018/12/27/Schnorr-Scheme/</id>
    <published>2018-12-27T07:25:46.000Z</published>
    <updated>2018-12-30T03:04:40.740Z</updated>
    
    <content type="html"><![CDATA[<p>Schnorr机制是一种基于离散对数难题的知识证明机制，由德国数学家和密码学家Claus-Peter Schnorr在1990年提出。这种知识证明机制具有实现简单，验证速度较快等优点。最开始是为Smart Card这样的资源受限设备而设计。</p><p>经过这些年的发展，在原始的Schnorr机制上实现了多种多样的改进与功能，实现了高性能的数字签名，以及包括环签名，门限签名等复杂签名机制。</p><p>在这里参考Schnorr的论文与其他的参考资料，分析Schnorr机制的原始机制与实现。并分析现在主流的EdDSA的实现ED25519，以及如何在Schnorr机制上建立的复杂签名机制。</p><a id="more"></a><ol type="1"><li><a href="https://tiannian.github.io/2018/12/27/Schnorr-Scheme/">数字签名机制 - Schnorr Scheme</a></li><li><a href="https://tiannian.github.io/2018/12/28/ed25519/">数字签名机制- ED25519</a></li></ol><blockquote><p>本文中所有出现的变量，小写字母表示标量，即一个数字，在这里指整数；大写字母表示离散对数问题中的参数，例如：椭圆曲线中的点。</p></blockquote><h3 id="original-schnorr-scheme">Original Schnorr Scheme</h3><p>原始的Schnorr机制是一个交互式的机制。允许在任何拥有相同生成元（指在离散对数问题中）的协议参与者双方，证明某一方拥有私钥 <span class="math inline">\(x\)</span> 而不需要直接交换它。其中双方都拥有的生成元设为 <span class="math inline">\(G\)</span> ，证明者拥有私钥 <span class="math inline">\(x\)</span> 。验证者从证明者处取得 <span class="math inline">\(Y\)</span> ，其中 <span class="math inline">\(Y = xG\)</span>，<span class="math inline">\(Y\)</span> 即公钥。</p><p>Original Schnorr Signature的协议流程如下：</p><ol type="1"><li>证明者随机选择一个标量 <span class="math inline">\(r_1\)</span>，然后计算出 <span class="math inline">\(R = r_1G\)</span>。并将 <span class="math inline">\(R\)</span> 发送至验证者。</li><li>验证者回应一个随机的标量 <span class="math inline">\(r_2\)</span>。</li><li>证明者回应一个标量<span class="math inline">\(s\)</span>，通过公式 <span class="math inline">\(s = r_1 + r_2x\)</span> 计算。</li></ol><p>因为离散对数问题是困难的，因此验证者不会知道 <span class="math inline">\(x, r_1\)</span>的值，验证者仅知道由 <span class="math inline">\(x, r_1\)</span>计算得到的 <span class="math inline">\(Y, R\)</span>。但是验证者可以通过以下计算来验证<span class="math inline">\(s\)</span>是正确的：</p><ul><li>由于<span class="math inline">\(s = r_1 + r_2x\)</span>，等式两边同时添加相同的生成元可得 <span class="math inline">\(sG = r_1G + r_2xG\)</span>。</li><li>由于<span class="math inline">\(R = r_1G\)</span>，<span class="math inline">\(Y = xG\)</span>，可以化简得到 <span class="math inline">\(sG = R + r_2Y\)</span>。</li></ul><p>其中 <span class="math inline">\(G\)</span> 是生成元，双方都可知，<span class="math inline">\(R, Y, s, r_2\)</span> 验证者都知道，所以验证者可以轻松验证化简过的公式。</p><p>这个过程是零知识的，因为验证者并不能得到私钥 <span class="math inline">\(x\)</span> 的值，却可以通过计算与通讯的方式验证证明者确实拥有私钥 <span class="math inline">\(x\)</span>。</p><h3 id="problem-of-original-schnorr-scheme">Problem of Original Schnorr Scheme</h3><p>然而这样交互式的过程，会导致验证者通过"fork"的方式获得私钥 <span class="math inline">\(x\)</span>。验证者只需要简单的提供两个不同的随机值 <span class="math inline">\(r_2^1, r_2^2\)</span>，并要求证明者计算 <span class="math inline">\(s_1 = r_1 + r_2^1x, s_2 = r_1 + r_2^2x\)</span>，即可计算出<span class="math inline">\(x = (s_1 - s_2)/(r_2^1 - r_2^2)\)</span>。这样一来，这个过程便无法公开的验证，因为一旦两个验证者相互串通，交换自己得到的值，便可以推出私钥<span class="math inline">\(x\)</span>。</p><p>为了解决这个问题，后续将会通过对现有的协议进行Fiat–Shamir变换，使用Random oracles改造这个算法来使Schnorr原始的Schnorr Scheme变成可公开验证的非交互式算法。</p><h3 id="fiatshamir-and-random-oracles">Fiat–Shamir and Random oracles</h3><p>上述原始Schnorr Scheme中存在的私钥泄露问题使得算法无法在公开的环境下使用。通过将原始的交互式协议转变为非交互式协议可以解决这个问题。</p><p>Fiat–Shamir变换是一种利用交互式零知识证明方案创建数字签名的方式。根据Fiat–Shamir变换，我们可以将原始方案中的证明者采用随机数预言机（Random oracle）来代替，利用这样的方式构造数字签名。</p><p>随机数预言机，即随机数函数，是一种针对任意输入得到的输出之间是项目独立切均匀分布的函数。理想的随机数预言机并不存在，在实现中，经常采用密码学哈希函数作为随机数预言机。</p><p>原本的设计中，Schnorr签名是一种交互式协议，需要一个实际存在的验证者与参与者，而根据Fiat-Shamir转换，可以将具体的验证者采用随机数预言机来代替。将验证者替换为随机数预言机后，外部的验证者便无法通过交换 <span class="math inline">\(r_2\)</span>来推出私钥 <span class="math inline">\(x\)</span> ，原本的 <span class="math inline">\(r_2\)</span> 采用随机数预言机产生的随机数来表示。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Schnorr机制是一种基于离散对数难题的知识证明机制，由德国数学家和密码学家Claus-Peter Schnorr在1990年提出。这种知识证明机制具有实现简单，验证速度较快等优点。最开始是为Smart Card这样的资源受限设备而设计。&lt;/p&gt;
&lt;p&gt;经过这些年的发展，在原始的Schnorr机制上实现了多种多样的改进与功能，实现了高性能的数字签名，以及包括环签名，门限签名等复杂签名机制。&lt;/p&gt;
&lt;p&gt;在这里参考Schnorr的论文与其他的参考资料，分析Schnorr机制的原始机制与实现。并分析现在主流的EdDSA的实现ED25519，以及如何在Schnorr机制上建立的复杂签名机制。&lt;/p&gt;
    
    </summary>
    
    
      <category term="cryptography" scheme="https://tiannian.github.io/tags/cryptography/"/>
    
      <category term="schnorr scheme" scheme="https://tiannian.github.io/tags/schnorr-scheme/"/>
    
      <category term="digital signature" scheme="https://tiannian.github.io/tags/digital-signature/"/>
    
      <category term="ED25519" scheme="https://tiannian.github.io/tags/ED25519/"/>
    
      <category term="EdDSA" scheme="https://tiannian.github.io/tags/EdDSA/"/>
    
  </entry>
  
</feed>
