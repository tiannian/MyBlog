<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NianZhe</title>
  
  <subtitle>Nian is made up by Jin and Xin</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tiannian.github.io/"/>
  <updated>2019-02-13T13:11:40.531Z</updated>
  <id>https://tiannian.github.io/</id>
  
  <author>
    <name>Tiannian Du</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>parsec-protocol</title>
    <link href="https://tiannian.github.io/2019/02/13/blockchain/consensus/parsec-protocol/"/>
    <id>https://tiannian.github.io/2019/02/13/blockchain/consensus/parsec-protocol/</id>
    <published>2019-02-13T09:40:57.000Z</published>
    <updated>2019-02-13T13:11:40.531Z</updated>
    
    <content type="html"><![CDATA[<p>PARSEC是由Maidsafe项目提出的一套共识机制。PARSEC采用了与Hashgraph类似的设计，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PARSEC是由Maidsafe项目提出的一套共识机制。PARSEC采用了与Hashgraph类似的设计，&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="blockchain" scheme="https://tiannian.github.io/tags/blockchain/"/>
    
      <category term="consensus" scheme="https://tiannian.github.io/tags/consensus/"/>
    
      <category term="byzantine" scheme="https://tiannian.github.io/tags/byzantine/"/>
    
      <category term="hashgraph" scheme="https://tiannian.github.io/tags/hashgraph/"/>
    
  </entry>
  
  <entry>
    <title>QUIC协议翻译 - draft-ietf-quic-transport-latest Part 1.</title>
    <link href="https://tiannian.github.io/2019/02/13/network/quic/draft-ietf-quic-transport-latest-1/"/>
    <id>https://tiannian.github.io/2019/02/13/network/quic/draft-ietf-quic-transport-latest-1/</id>
    <published>2019-02-13T03:09:28.000Z</published>
    <updated>2019-02-13T13:11:40.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="abstract">Abstract</h2><p>本文档定义了QUIC传输协议的核心。随附文档描述了QUIC的丢失检测和拥塞控制以及使用TLS进行密钥协商。</p><a id="more"></a><h3 id="简介">1. 简介</h3><p>QUIC是一种多路复用且安全的通用传输协议，它具有如下特性：</p><ul><li>流复用</li><li>流和连接级控制</li><li>低延迟连接建立</li><li>连接迁移和弹性的NAT重绑定</li><li>经过加密与认证的包头和负载</li></ul><p>QUIC使用UDP作为基础，以避免需要更改旧版客户端操作系统和中间件。 QUIC验证其所有包头并加密它交换的大多数数据，包括其信令，以避免引起对中间件的依赖。</p><h4 id="文档结构">1.1 文档结构</h4><p>本文档描述了核心QUIC协议，其结构如下。</p><ul><li>流是QUIC提供的基本服务抽象。<ul><li><strong>第2节</strong> 描述了与流相关的核心概念，</li><li><strong>第3节</strong> 提供了流的参考模型，</li><li><strong>第4节</strong> 概述了流量控制的操作。</li></ul></li><li>连接是QUIC端点进行通信的主体。<ul><li><strong>第5节</strong> 描述了流相关的核心概念，</li><li><strong>第6节</strong> 描述了版本协商，</li><li><strong>第7节</strong> 详细描述了建立连接的过程，</li><li><strong>第8节</strong> 明确关键的拒绝服务缓解机制，</li><li><strong>第9节</strong> 描述了端点如何迁移连接到新的网络路径上，</li><li><strong>第10节</strong> 列出了结束已经打开的流的选项，</li><li><strong>第11节</strong> 提供了对错误处理的通用指导</li></ul></li><li>数据包和数据帧是QUIC通讯的基础单元。<ul><li><strong>第12节</strong> 描述了数据包和数据帧相关的概念，</li><li><strong>第13节</strong> 定义了传输，重传，和确认的模型</li><li><strong>第14节</strong> 明确了管理数据包大小的规则</li></ul></li><li>最后，QUIC协议元素的编码细节描述如下：<ul><li><strong>第15节</strong> （版本）</li><li><strong>第16节</strong> （整数编码）</li><li><strong>第17节</strong> （数据包头）</li><li><strong>第18节</strong> （传输参数）</li><li><strong>第19节</strong> （数据帧）</li><li><strong>第18节</strong> （错误）</li></ul></li></ul><p>随附文档描述了QUIC的丢失检测和拥塞控制[QUIC-RECOVERY]，以及使用TLS进行密钥协商[QUIC-TLS]。</p><p>本文档定义了QUIC版本1，它符合[QUIC-INVARIANTS]中的协议不变量。</p><h4 id="公约和定义">1.2 公约和定义</h4><blockquote><p>略</p></blockquote><h4 id="符号约定">1.3 符号约定</h4><p>本文档中的数据包和框架图使用[RFC2360]第3.1节中描述的格式，并附带以下附加约定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[x]: 表示x是可选的</span><br><span class="line">x(A): 表示x有A bit长</span><br><span class="line">x(A/B/C): 表示x有A，B或C bit长</span><br><span class="line">x(i): 表示x使用第16节描述的可变长编码</span><br><span class="line">x(*): 表示x是可变长度的</span><br></pre></td></tr></table></figure><h3 id="流">2. 流</h3><p>QUIC中的流为应用程序提供轻量级，有序的字节流抽象。 从另一个角度来说流是QUIC作为弹性的消息抽象。</p><p>可以通过发送数据来创建流。与流管理相关的过程（结束，取消和流控制）都旨在实现最小的开销。例如，单个STREAM帧可以打开流，携带数据或关闭流。流也可以是长期存在的，并且可以持续整个连接的持续时间。</p><p>流可以由任一端点创建，可以同时发送与其他流不同的数据，并且可以被取消。 QUIC没有提供任何确保不同流之间字节排序的方法。</p><p>QUIC允许任意数量的流同时运行，并且可以在任何流上发送任意数量的数据，受流控制约束（参见第4节）和流限制。</p><h4 id="流类型与识别码">2.1 流类型与识别码</h4><p>流可以是单向的或双向的。单向流在一个方向上传输数据：从流的发起者到对等方。双向流允许数据在两个方向上发送。</p><p>通过数值在连接中标识流，称为流ID。流ID对于流是唯一的。 QUIC端点绝不能重用连接中的流ID。流ID被编码为可变长度整数（参见第16节）。</p><p>流ID的最低有效位（0x1）标识流的发起者。客户端发起的流具有偶数编号的流ID（位设置为0），服务器发起的流具有奇数编号的流ID（位设置为1）。</p><p>流ID的第二个最低有效位（0x2）区分双向流（位设置为0）和单向流（位设置为1）。</p><p>因此，来自流ID的最低有效两位将流识别为四种类型之一，如表1中所总结的。</p><table><thead><tr class="header"><th>掩码</th><th>发起者</th><th>流类型</th></tr></thead><tbody><tr class="odd"><td>0x1</td><td>客户端发起</td><td>双向流</td></tr><tr class="even"><td>0x2</td><td>服务端发起</td><td>双向流</td></tr><tr class="odd"><td>0x3</td><td>客户端发起</td><td>单向流</td></tr><tr class="even"><td>0x4</td><td>服务端发起</td><td>单向流</td></tr></tbody></table><p>在每种类型中，使用数字增加的流ID创建流。不按顺序使用的流ID将会导致该类型的所有具有较低编号的流ID的流也被打开。</p><p>客户端打开的第一个双向流的流ID为0。</p><h4 id="接收和发送数据">2.2 接收和发送数据</h4><p>STREAM帧封装了应用程序发送的数据。端点使用STREAM帧中的Stream ID和Offset字段按顺序放置数据。</p><p>端点必须能够将流数据作为有序字节流传递给应用程序。提供有序的字节流要求端点缓冲任何无序接收的数据，直到宣称流量控制限制。</p><p>QUIC没有特别规定无序传输流数据。但是，实现可以选择提供将数据无序传递到接收应用程序的能力。</p><p>端点可以多次接收相同流偏移的流的数据。已经收到的数据可以被丢弃。如果多次发送，给定偏移量的数据不得改变;端点可以将流中相同偏移量的不同数据的接收视为PROTOCOL_VIOLATION类型的连接错误。</p><p>Streams是一种有序的字节流抽象，QUIC中不存在其他可见的结构。当数据传输，数据包丢失后重传数据或者数据在接收器传送到应用程序时，预计不会保留STREAM帧边界。【TODO】</p><p>端点不得在任何流上发送数据，而不确保它在同级设置的流量控制限制范围内。流量控制在第4节中详细描述。【TODO】</p><h4 id="流优先级">2.3 流优先级</h4><p>如果分配给流的资源被正确地优先化，则流复用可以对应用性能产生显着影响。</p><p>QUIC不提供交换优先级信息的框架。相反，它依赖于从使用QUIC的应用程序接收优先级信息。</p><p>QUIC实现应该提供应用程序可以指示流的相对优先级的方式。在决定将资源专用于哪些流时，实现应该使用应用程序提供的信息。</p><h3 id="流状态">3. 流状态</h3><p>本节按发送或接收组件描述流。描述了两个状态机：一个是使用流传输数据时端点的状态机（第3.1节），一个是使用流接收数据时端点的状态机（第3.2节）。</p><p>单向流直接使用适用的状态机。双向流使用两个状态机。在大多数情况下，无论流是单向还是双向，这些状态机的使用都是相同的。打开流的条件对于双向流来说稍微复杂一些，因为发送侧或接收侧的打开导致流在两个方向上打开。</p><p>端点必须按流ID的递增顺序打开相同类型的流。</p><blockquote><p>备注：这些状态机的信息很大。本文档使用流状态来描述何时以及如何发送不同类型的帧以及在接收到不同类型的帧时预期的反应的规则。虽然这些状态机旨在用于实现QUIC，但这些状态并非旨在约束实现。实现可以定义不同的状态机，只要其行为与实现这些状态的实现一致即可。</p></blockquote><h4 id="发送流状态">3.1 发送流状态</h4><p>图1显示了将数据发送到对等方的流的一部分的状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    o</span><br><span class="line">    | Create Stream (Sending)</span><br><span class="line">    | Peer Creates Bidirectional Stream</span><br><span class="line">    v</span><br><span class="line">+-------+</span><br><span class="line">| Ready | Send RESET_STREAM</span><br><span class="line">|       |-----------------------.</span><br><span class="line">+-------+                       |</span><br><span class="line">    |                           |</span><br><span class="line">    | Send STREAM /             |</span><br><span class="line">    |      STREAM_DATA_BLOCKED  |</span><br><span class="line">    |                           |</span><br><span class="line">    | Peer Creates              |</span><br><span class="line">    |      Bidirectional Stream |</span><br><span class="line">    v                           |</span><br><span class="line">+-------+                       |</span><br><span class="line">| Send  | Send RESET_STREAM     |</span><br><span class="line">|       |----------------------&gt;|</span><br><span class="line">+-------+                       |</span><br><span class="line">    |                           |</span><br><span class="line">    | Send STREAM + FIN         |</span><br><span class="line">    v                           v</span><br><span class="line">+-------+                   +-------+</span><br><span class="line">| Data  | Send RESET_STREAM | Reset |</span><br><span class="line">| Sent  |------------------&gt;| Sent  |</span><br><span class="line">+-------+                   +-------+</span><br><span class="line">    |                           |</span><br><span class="line">    | Recv All ACKs             | Recv ACK</span><br><span class="line">    v                           v</span><br><span class="line">+-------+                   +-------+</span><br><span class="line">| Data  |                   | Reset |</span><br><span class="line">| Recvd |                   | Recvd |</span><br><span class="line">+-------+                   +-------+</span><br></pre></td></tr></table></figure><p>端点启动的流的发送部分（客户端类型0和2，服务器类型1和3）由应用程序打开。 <code>Ready</code>状态表示新创建的流，该流能够接受来自应用程序的数据。可以在此状态下缓冲流数据以准备发送。</p><p>发送第一个STREAM或STREAM_DATA_BLOCKED帧会导致流的发送部分进入<code>Send</code>状态。实现可以选择直到它发送第一帧并进入该状态时再将流ID分配给流，这可以允许更好的流优先级。</p><p>由对等方发起的双向流的发送部分（服务器类型0，客户端类型1）进入<code>Ready</code>状态时，如果接收部分进入<code>Recv</code>状态则立即转换到<code>Send</code>状态（第3.2节）。</p><p>在<code>Send</code>状态中，端点通过STEAM帧发送（在必要时重新发送 ）流数据。端点遵守其对等方设置的流量控制限制，并继续接受和处理MAX_STREAM_DATA帧。如果它被流量控制阻塞通过流或者连接发送数据，则<code>Send</code>状态的端点会生成STREAM_DATA_BLOCKED帧。</p><p>在应用程序指示已发送所有流数据并且发送包含FIN位的STREAM帧之后，流的发送部分进入<code>Data Sent</code>状态。从该状态开始，端点仅在必要时重传流数据。端点不需要检查流控制限制，也不需要为此状态的流发送STREAM_DATA_BLOCKED帧。可以接收MAX_STREAM_DATA帧，直到对等体接收到最终流偏移。端点可以安全地忽略它从对等端接收到的处于此状态的流的任何MAX_STREAM_DATA帧。</p><p>一旦成功确认了所有流数据，流的发送部分就进入<code>Data Recvd</code>状态，这是一种结束状态。</p><p>从任何<code>Ready</code>，<code>Send</code>或<code>Data Sent</code>状态，应用程序可以发信号通知它希望放弃流数据的传输。或者，端点可能从其对等端接收STOP_SENDING帧。在任何一种情况下，端点都会发送RESET_STREAM帧，这会导致流进入<code>Reset Sent</code>状态。</p><p>端点可以发送RESET_STREAM作为提及流的第一帧，这会导致该流的发送部分打开，然后立即转换到<code>Reset Sent</code>状态。</p><p>一旦确认了包含RESET_STREAM的分组，则流的发送部分进入<code>Reset Recvd</code>状态，这是终结状态。</p><h4 id="接收流状态">3.2 接收流状态</h4><p>图2显示了从对等方接收数据的流部分的状态。接收流的一部分的状态仅镜像对等体流的发送部分的一些状态。流的接收部分不跟踪发送部分上无法观察到的状态，例如<code>Ready</code>状态。相反，流的接收部分跟踪向应用程序传送数据，其中一些数据不能被发送者观察到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    o</span><br><span class="line">    | Recv STREAM / STREAM_DATA_BLOCKED / RESET_STREAM</span><br><span class="line">    | Create Bidirectional Stream (Sending)</span><br><span class="line">    | Recv MAX_STREAM_DATA / STOP_SENDING (Bidirectional)</span><br><span class="line">    | Create Higher-Numbered Stream</span><br><span class="line">    v</span><br><span class="line">+-------+</span><br><span class="line">| Recv  | Recv RESET_STREAM</span><br><span class="line">|       |-----------------------.</span><br><span class="line">+-------+                       |</span><br><span class="line">    |                           |</span><br><span class="line">    | Recv STREAM + FIN         |</span><br><span class="line">    v                           |</span><br><span class="line">+-------+                       |</span><br><span class="line">| Size  | Recv RESET_STREAM     |</span><br><span class="line">| Known |----------------------&gt;|</span><br><span class="line">+-------+                       |</span><br><span class="line">    |                           |</span><br><span class="line">    | Recv All Data             |</span><br><span class="line">    v                           v</span><br><span class="line">+-------+ Recv RESET_STREAM +-------+</span><br><span class="line">| Data  |--- (optional) ---&gt;| Reset |</span><br><span class="line">| Recvd |  Recv All Data    | Recvd |</span><br><span class="line">+-------+&lt;-- (optional) ----+-------+</span><br><span class="line">    |                           |</span><br><span class="line">    | App Read All Data         | App Read RST</span><br><span class="line">    v                           v</span><br><span class="line">+-------+                   +-------+</span><br><span class="line">| Data  |                   | Reset |</span><br><span class="line">| Read  |                   | Read  |</span><br><span class="line">+-------+                   +-------+</span><br></pre></td></tr></table></figure><p>当为该流接收到第一个STREAM，STREAM_DATA_BLOCKED或RESET_STREAM时，将创建由对等方发起的流的接收部分（客户端的类型1和3，或服务器的0和2）。对于由对等方发起的双向流，接收流的发送部分的MAX_STREAM_DATA或STOP_SENDING帧也会创建接收部分。流的接收部分的初始状态是<code>Recv</code>。</p><p>当端点发起的双向流的发送部分（客户端类型0，服务器类型1）进入<code>Ready</code>状态时，流的接收部分进入<code>Recv</code>状态。</p><p>当从该流的对等体收到MAX_STREAM_DATA或STOP_SENDING帧时，端点将打开双向流。为未打开的流接收MAX_STREAM_DATA帧表示远程对等体已打开流并提供流控制分数。为未打开的流接收STOP_SENDING帧表示远程对等体不再希望接收此流上的数据。如果数据包丢失或重新排序，则任何一个帧都可能在STREAM或STREAM_DATA_BLOCKED帧之前到达。</p><p>在创建流之前，必须创建具有较低编号的流ID的所有相同类型的流。这可确保流的创建顺序在两个端点上保持一致。</p><p>在“Recv”状态中，端点接收STREAM和STREAM_DATA_BLOCKED帧。传入的数据被缓冲，可以重新组合成正确的顺序以便传送到应用程序。当应用程序使用数据并且缓冲区空间可用时，端点发送MAX_STREAM_DATA帧以允许对等方发送更多数据。</p><p>当接收到具有FIN位的STREAM帧时，流的最终大小是已知的（参见第4.4节）。然后，流的接收部分进入<code>Size Known</code>状态。在此状态下，端点不再需要发送MAX_STREAM_DATA帧，它只接收流数据的任何重传。</p><p>一旦接收到流的所有数据，接收部分就进入<code>Data Recvd</code>状态。这可能是由于接收到导致转换为<code>Size Known</code>的相同STREAM帧而发生的。在此状态下，端点具有所有流数据。可以丢弃它为流接收的任何STREAM或STREAM_DATA_BLOCKED帧。</p><p><code>Data Recvd</code>状态持续存在，直到流数据已传送到应用程序。一旦传送了流数据，流就进入<code>Data Read</code>状态，这是一种终结状态。</p><p>在<code>Recv</code>或<code>Size Known</code>状态下接收到RESET_STREAM帧会使流进入<code>Reset Recvd</code>状态。这可能导致流数据传递到应用程序中断。</p><p>当流处于<code>Data Recvd</code>状态接收到RESET_STREAM时，端点可能接收到所有流数据。类似地，在接收RESET_STREAM帧之后剩余的流数据可能到达（<code>Reset Recvd</code>状态）。一个实现可以自由选择管理这种情况。发送RESET_STREAM意味着端点无法保证流数据的传递。但是，如果收到RESET_STREAM，则不要求不传送流数据。实现可以中断流数据的传送，丢弃未使用的任何数据，并立即发出RESET_STREAM的接收信号。或者，如果流数据被完全接收并且缓冲以供应用程序读取，则可以抑制或保留RESET_STREAM信号。在后一种情况下，流的接收部分从<code>Reset Recvd</code>转换为<code>Data Recvd</code>。</p><p>一旦应用程序已经被传送指示流被重置的信号，流的接收部分就转换到<code>Reset Recvd</code>状态，这是终结状态。</p><h4 id="允许的帧类型">3.3 允许的帧类型</h4><p>流的发送方只发送三种帧类型，这些类型会影响发送方或接收方的流状态：STREAM（第19.8节），STREAM_DATA_BLOCKED（第19.13节）和RESET_STREAM（第19.4节）。</p><p>发送方不得从终结状态（<code>Data Recvd</code>或<code>Reset Recvd</code>）发送任何这些帧。发送者在发送RESET_STREAM后不得发送STREAM或STREAM_DATA_BLOCKED。也就是说，在终结状态和<code>Reset Sent</code>状态下。接收器可以在任何状态下接收这三个帧中的任何一个，因为可能延迟传送携带它们的分组。</p><p>流的接收器发送MAX_STREAM_DATA（第19.10节）和STOP_SENDING帧（第19.5节）。</p><p>接收器仅发送处于<code>Recv</code>状态的MAX_STREAM_DATA。接收器可以在没有收到RESET_STREAM帧的任何状态下发送STOP_SENDING;这是除<code>Reset Recvd</code>或<code>Reset Read</code>以外的状态。但是，在<code>Data Recvd</code>状态下发送STOP_SENDING帧几乎没有价值，因为已收到所有流数据。由于数据包的延迟传送，发送方可以在任何状态下接收这两个帧中的任何一个。</p><h4 id="双向流状态">3.4 双向流状态</h4><p>双向流由发送和接收部分组成。实现可以将双向流的状态表示为发送和接收流状态的组合。当发送或接收部分处于非终结状态时，最简单的模型将流呈现为<code>open</code>，而当发送和接收流都处于终结状态时，流呈现为<code>closed</code>。</p><p>表2显示了与HTTP/2 中的流状态松散对应的双向流状态的复杂映射。这表明发送或接收部分流的多个状态被映射到相同的复合状态。请注意，这只是这种映射的一种可能性;此映射要求在转换到<code>closed</code>或<code>half-closed</code>状态之前确认数据。</p><table><thead><tr class="header"><th>发送部分</th><th>接收部分</th><th>复合状态</th></tr></thead><tbody><tr class="odd"><td>No Stream/Ready</td><td>No Stream/Recv *1</td><td>idle</td></tr><tr class="even"><td>Ready/Send/Data Sent</td><td>Recv/Size Known</td><td>open</td></tr><tr class="odd"><td>Ready/Send/Data Sent</td><td>Data Recvd/Data Read</td><td>half-closed (remote)</td></tr><tr class="even"><td>Ready/Send/Data Sent</td><td>Reset Recvd/Reset Read</td><td>half-closed (remote)</td></tr><tr class="odd"><td>Data Recvd</td><td>Recv/Size Known</td><td>half-closed (local)</td></tr><tr class="even"><td>Reset Sent/Reset Recvd</td><td>Recv/Size Known</td><td>half-closed (local)</td></tr><tr class="odd"><td>Reset Sent/Reset Recvd</td><td>Data Recvd/Data Read</td><td>closed</td></tr><tr class="even"><td>Reset Sent/Reset Recvd</td><td>Reset Recvd/Reset Read</td><td>closed</td></tr><tr class="odd"><td>Data Recvd</td><td>Data Recvd/Data Read</td><td>closed</td></tr><tr class="even"><td>Data Recvd</td><td>Reset Recvd/Reset Read</td><td>closed</td></tr></tbody></table><blockquote><p>备注 (*1)：如果尚未创建流，则该流被认为是<code>idle</code>，或者如果流的接收部分处于“Recv”状态而尚未接收到任何帧，则该流被认为是<code>idle</code>。</p></blockquote><h4 id="询问状态过渡">3.5 询问状态过渡</h4><p>如果端点不再对它在流上接收的数据感兴趣，它可以发送一个STOP_SENDING帧来标识该流，以提示在相反方向关闭流。这通常表示接收应用程序不再读取它从流中接收的数据，但不保证将忽略传入的数据。</p><p>发送STOP_SENDING后收到的STREAM帧仍计入连接和流量控制，即使这些帧在接收时将被丢弃。</p><p>STOP_SENDING帧请求接收端点发送RESET_STREAM帧。如果流处于就绪或发送状态，则接收STOP_SENDING帧的端点必须发送RESET_STREAM帧。如果流处于数据发送状态并且任何未完成的数据被声明丢失，则端点应该发送RESET_STREAM帧代替重传。</p><p>端点应该将错误代码从STOP_SENDING帧复制到它发送的RESET_STREAM帧，但是可以使用任何应用程序错误代码。发送STOP_SENDING帧的端点可以忽略它接收的任何RESET_STREAM帧中携带的错误代码。</p><p>如果在已经处于<code>Data Sent</code>状态的流上接收到STOP_SENDING帧，则希望停止在该流上重传先前发送的STREAM帧的端点必须首先发送RESET_STREAM帧。</p><p>STOP_SENDING应该仅针对未被对等方重置的流发送。 STOP_SENDING对于<code>Recv</code>或<code>Size Known</code>状态的流最有用。</p><p>如果包含先前STOP_SENDING的数据包丢失，则端点应发送另一个STOP_SENDING帧。但是，一旦为流接收到所有流数据或RESET_STREAM帧（即，流处于<code>Recv</code>或<code>Size Known</code>以外的任何状态）发送STOP_SENDING帧是不必要的。</p><p>希望终止双向流的两个方向的端点可以通过发送RESET_STREAM来终止一个方向，并且它可以通过发送STOP_SENDING帧来鼓励在相反方向上的快速终止。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;abstract&quot;&gt;Abstract&lt;/h2&gt;
&lt;p&gt;本文档定义了QUIC传输协议的核心。随附文档描述了QUIC的丢失检测和拥塞控制以及使用TLS进行密钥协商。&lt;/p&gt;
    
    </summary>
    
    
      <category term="QUIC" scheme="https://tiannian.github.io/tags/QUIC/"/>
    
      <category term="translate" scheme="https://tiannian.github.io/tags/translate/"/>
    
      <category term="RFC" scheme="https://tiannian.github.io/tags/RFC/"/>
    
      <category term="Protocol" scheme="https://tiannian.github.io/tags/Protocol/"/>
    
  </entry>
  
  <entry>
    <title>QUIC协议翻译 - draft-ietf-quic-invariants-latest</title>
    <link href="https://tiannian.github.io/2019/02/13/network/quic/draft-ietf-quic-invariants-latest/"/>
    <id>https://tiannian.github.io/2019/02/13/network/quic/draft-ietf-quic-invariants-latest/</id>
    <published>2019-02-13T03:01:12.000Z</published>
    <updated>2019-02-13T13:11:40.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="abstract">Abstract</h2><p>本文档定义了QUIC传输协议的属性，随着协议的新版本的开发，这些属性随时间保持不变。</p><a id="more"></a><h3 id="简介">1. 简介</h3><p>除了提供安全的多路传输外，QUIC <a href="https://quicwg.org/base-drafts/draft-ietf-quic-invariants.html#QUIC-TRANSPORT" target="_blank" rel="noopener">[QUIC-TRANSPORT]</a>还包括协商版本的能力。这允许协议随着时间的推移而改变以响应新的要求。协议的许多特征将在不同版本之间变化。</p><p>本文档描述了QUIC的子集，旨在在开发和部署新版本时保持稳定。所有这些不变特性都是与IP版本无关的。</p><p>本文档的主要目标是确保可以部署新版本的QUIC。本文档记录了协议中无法变更的属性，旨在保留更改协议其他任何部分的能力。因此，除非在本文件中具体描述的内容，协议的任何方面都可以在不同版本之间发生改变。</p><p>附录A是根据QUIC版本1的知识可能做出的一些不正确假设的非详尽列表;这些不适用于每个版本的QUIC。</p><h3 id="公约和定义">2. 公约和定义</h3><blockquote><p>略</p></blockquote><h3 id="quic的极其抽象的描述">3. QUIC的极其抽象的描述</h3><p>QUIC是两个端点之间面向连接的协议。这些端点交换UDP数据报。UDP数据报中包含QUIC数据包。 QUIC端点使用QUIC数据包建立QUIC连接，这是这些端点之间的共享的协议状态。</p><h3 id="quic数据包头">4. QUIC数据包头</h3><p>QUIC数据包是QUIC端点交换的UDP数据报的内容。本文档描述了这些数据报的具体内容。</p><p>QUIC定义了两种类型的包头：长和短。长包头的第一个字节的最高有效标志位被置1，短包头的该位置0。</p><p>除了此处描述的值之外，QUIC数据包的有效负载是特定于版本的并且具有任意长度。</p><h4 id="长包头">4.1 长包头</h4><p>长包头采用图1中描述的形式。具有特定于版本的语义的位标记为X.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+</span><br><span class="line">|1|X X X X X X X|</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                         Version (32)                          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|DCIL(4)|SCIL(4)|</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|               Destination Connection ID (0/32..144)         ...</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                 Source Connection ID (0/32..144)            ...</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X  ...</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>具有长报头的QUIC数据包将第一个字节的高位设置为1.该字节中的所有其他位都是特定于版本的。</p><p>接下来的四个字节包括一个32位版本字段（参见第4.4节）。</p><p>下一个字节包含后面两个连接ID（参见第4.3节）的字节长度。每个ID的长度编码为4位无符号整数。目标连接ID（DCIL）的长度占用字节的高位，源连接ID（SCIL）的长度占用字节的低位。编码长度为0表示连接ID的长度也为0字节。非零编码长度增加3以获得连接ID的全长;因此，最终值为0或长度为4到18个字节（包括端点）。例如，值为0xe0的字节描述17字节的目标连接ID和零字节的源连接ID。</p><p>连接ID长度后跟两个连接ID。分别是接收者相关联的连接ID（目的地连接ID）与发送者相关联的连接ID（源连接ID）。</p><p>数据包的其余部分包含特定于版本的内容。</p><h4 id="短包头">4.2 短包头</h4><p>短包头采用图2中描述的形式。具有特定于版本的语义的位标记为X.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+</span><br><span class="line">|0|X X X X X X X|</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                 Destination Connection ID (*)               ...</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X  ...</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>具有短报头的QUIC数据包将第一个字节的高位设置为0。</p><p>具有短报头的QUIC分组包括目的地连接ID。短标头不包括“连接ID长度”，“源连接ID”或“版本”字段。</p><p>数据包的其余部分具有特定于版本的语义。</p><h4 id="连接id">4.3 连接ID</h4><p>连接ID是任意长度的不透明字段。</p><p>连接ID的主要功能是确保较低协议层（UDP，IP和以下）的寻址更改不会导致QUIC连接的数据包传递到错误的端点。端点和支持它们的中介使用连接ID来确保每个QUIC数据包都可以传递到端点的正确实例。在端点处，连接ID用于标识数据包所针对的QUIC连接。</p><p>每个端点使用特定于版本的方法选择连接ID。相同QUIC连接的数据包可能使用不同的连接ID值。</p><h4 id="版本">4.4 版本</h4><p>QUIC版本使用32位整数标识，以网络字节顺序编码。版本0保留用于版本协商（参见第5节）。所有其他版本号都可能有效。</p><p>本文档中描述的属性适用于所有版本的QUIC。不符合本文档中描述的属性的协议不是QUIC。未来的文档可能会描述适用于特定QUIC版本或一系列QUIC版本的其他属性。</p><h3 id="版本协商">5. 版本协商</h3><p>QUIC端点接收具有长报头的数据包及其不理解或不支持的版本时，可能会发送版本协商数据包作为响应。具有短标头的数据包不会触发版本协商。</p><p>版本协商数据包设置第一个字节的高位，因此它符合第4.1节中定义的具有长标头的数据包的格式。 Version Negotiation数据包可由Version字段识别，该字段设置为0x00000000。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+</span><br><span class="line">|1|X X X X X X X|</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                       Version (32) = 0                        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|DCIL(4)|SCIL(4)|</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|               Destination Connection ID (0/32..144)         ...</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                 Source Connection ID (0/32..144)            ...</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Supported Version 1 (32)                   |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                   [Supported Version 2 (32)]                  |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">                               ...</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                   [Supported Version N (32)]                  |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>Version Negotiation数据包包含一个Supported Version字段列表，每个字段标识发送数据包的端点支持的版本。 “支持的版本”字段遵循“版本”字段。版本协商数据包不包含其他字段。端点必须忽略不包含支持的版本字段或截断的支持版本的数据包。</p><p>版本协商数据包不使用完整性或机密性保护。特定的QUIC版本可能会将数据包作为其连接建立过程的一部分进行身份验证。</p><p>端点必须包含它在目标连接ID字段中接收的数据包的源连接ID字段中的值。源连接ID的值必须从接收数据包的目标连接ID复制，该数据最初由客户端随机选择。回复两个连接ID可以使客户端确信服务器已收到数据包，并且版本协商数据包不是由路径外攻击者生成的。</p><p>接收版本协商数据包的端点可能会更改它决定用于后续数据包的版本。端点更改QUIC版本的条件取决于它选择的QUIC版本。</p><p>有关如何支持QUIC版本1的端点生成和使用版本协商数据包的详细说明，请参见[QUIC-TRANSPORT]。</p><h3 id="安全和隐私考量">6.安全和隐私考量</h3><p>中间件可能使用特定版本的QUIC的特征，并假设当其他版本的QUIC表现出相似的特征时，表达相同的底层语义。可能有许多这样的特征（见附录A）。已经做出一些努力来消除或掩盖QUIC版本1中的一些可观察特征，但其中许多仍然存在。其他QUIC版本可能会做出不同的设计决策，因此表现出不同的特征。</p><p>QUIC版本号不会出现在所有QUIC数据包中，这意味着可以根据特定于版本的特征从流中可靠地提取信息，这要求中间件为他们看到的每个连接ID保留状态。</p><p>本文档中描述的Version Negotiation数据包不受完整性保护;它只有适度的防止非路径攻击者插入的保护。 QUIC版本必须定义一种机制来验证它包含的值。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;abstract&quot;&gt;Abstract&lt;/h2&gt;
&lt;p&gt;本文档定义了QUIC传输协议的属性，随着协议的新版本的开发，这些属性随时间保持不变。&lt;/p&gt;
    
    </summary>
    
    
      <category term="QUIC" scheme="https://tiannian.github.io/tags/QUIC/"/>
    
      <category term="translate" scheme="https://tiannian.github.io/tags/translate/"/>
    
      <category term="RFC" scheme="https://tiannian.github.io/tags/RFC/"/>
    
      <category term="Protocol" scheme="https://tiannian.github.io/tags/Protocol/"/>
    
  </entry>
  
  <entry>
    <title>Strobe protocol framework分析 - Sponge Construction</title>
    <link href="https://tiannian.github.io/2018/12/28/cryptography/Strobe-Sponge/"/>
    <id>https://tiannian.github.io/2018/12/28/cryptography/Strobe-Sponge/</id>
    <published>2018-12-28T08:33:28.000Z</published>
    <updated>2019-02-13T13:11:40.540Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://strobe.sourceforge.io/" target="_blank" rel="noopener">Strobe</a>是一个面向物联网设计的密码学协议框架，目标是为了使加密协议更容易开发，部署，分析，并适用于微型物联网设备。在Strobe的设计中，仅使用了一个块函数Keccak-f来对消息进行加密和验证。</p><p>Strobe利用了Keccak的海绵结构（Sponge Construction）来设计。这使得在Strobe的基础上，可以实现包括密码学哈希函数（Cryptographic hash function），消息认证码（Message authentication code）等机制；可以构建对称加密机制，数字签名机制（通过Schnorr Scheme），密钥交换机制（通过DH算法），以及TLS等类似的密码协议。</p><p>在这里将会分析Strobe协议的组成以及其原理，以及如何在Strobe上构建密码协议。</p><p>在分析Strobe协议之前，首先需要明确什么是海绵结构。</p><a id="more"></a><ol type="1"><li><a href="https://tiannian.github.io/2018/12/28/strobe-sponge/">Strobe protocol framework - Sponge Construction</a></li></ol><p>海绵结构（Sponge Construction）是Keccak提出的一种密码学函数。最开始的海绵结构是为构造密码学哈希函数所设计。后来发现通过海绵结构不仅仅适用于具有固定输出长度的密码学哈希函数，同样也适用于具有固定输入长度的流密码机制。</p><p>现有的的哈希函数可以将任意长度的输入映射为固定长度输出（实际上包括SHA2在内的密码学哈希函数也都做不到任意长度的输入，只不过是因为现有的密码学哈希函数可容纳的输入长度上限太大，近似的看作输入长度无限），而海绵结构则是可以将任意长度的输入映射为任意长度的输出。同时它的输出就像是一个随机数预言机（Random Oracle），能够保证输出的随机性。</p><h2 id="cryptographic-sponge-functions">Cryptographic Sponge Functions</h2><p>说了这么多，到底什么是海绵结构呢？</p><p>在密码学中的“海绵”，比较正式的说法应该是密码学海绵函数（Cryptographic Sponge Functions）。这个函数就像是一个海绵一样，能够不断，多次的输入来自外部的数据；同时也能够像挤海绵里的水一样，多次向外输出数据。不同于现实中的海绵，这里的海绵是可以无限的输入数据，也可以无限的输出数据。</p><p>海绵结构是一个简单的迭代的结构。构造一个海绵结构需要两个元素：一个长度为<span class="math inline">\(b\)</span>的状态<span class="math inline">\(S\)</span>（state），在状态上展开迭代过程；以及一个用于操作状态，输入和输入长度都为<span class="math inline">\(b\)</span>的排列函数<span class="math inline">\(f\)</span>。</p><p><img src="f.png"></p><p>实际上这里的函数<span class="math inline">\(f\)</span>是一个纯函数，它接收状态作为传入，返回的是经过它处理后的状态。</p><p>而被传入函数<span class="math inline">\(f\)</span>的状态<span class="math inline">\(S\)</span>被分为两部分，分别是长度为<span class="math inline">\(r\)</span>的公共部分<span class="math inline">\(R\)</span>（rate），和长度为<span class="math inline">\(c\)</span>的私有部分<span class="math inline">\(C\)</span>（capacity）。</p><p><img src="split.png"></p><p>函数<span class="math inline">\(f\)</span>的作用是根据现有的排列（permutation）来迭代产生新的排列。最新的SHA-3算法采用的同样是海绵结构，它采用的排列函数<span class="math inline">\(f\)</span>是<strong>keccak-f[1600]</strong>。其中的1600代表这个函数的输入是1600位，输出同样是1600位。在Strobe中采用的排列函数<span class="math inline">\(f\)</span>是<strong>keccak-f[b]</strong>，其中<span class="math inline">\(b\)</span>是状态<span class="math inline">\(S\)</span>的长度，根据<strong>keccak-f[b]</strong>的设计，<span class="math inline">\(b\)</span>的取值只能是{200,400,800,1600}，长度单位是bit。</p><h2 id="keccak算法">keccak算法</h2><p>在<strong>keccak</strong>的处理过程中被分为两个过程，第一个部分是吸收过程，第二个部分是挤压过程。</p><p>吸收过程就是将输入的数据输入到海绵结构中。输入数据被填充后分割为多个块，每个块的长度与公共部分<span class="math inline">\(R\)</span>的长度相同，之后不断的将这些块与状态<span class="math inline">\(S\)</span>的公共部分<span class="math inline">\(R\)</span>异或，每次异或后都调用排列函数<span class="math inline">\(f\)</span>。</p><p><img src="message.png"></p><p>整个吸收过程是针对每一个输入数据块<span class="math inline">\(m_i\)</span>执行如下算法： <span class="math display">\[(r,c) = f(r \oplus m_i,c)\]</span> 吸收过程可以无限制的迭代下去，从这个角度来说，<strong>keccak</strong>可以吸收无限多的数据到状态中。</p><p>挤压过程就是从海绵结构中获得输出。当我们需要从海绵结构中获得输出时，我们从状态的公共部分读取输出，如果长度不够，那么可以利用<span class="math inline">\(f\)</span>去修改状态，继续读取新的公共部分。这个过程可以不断的继续重复下去，直到读取到足够的输出为止。</p><p><img src="squeeze.png"></p><p>这个过程就是现在SHA-3的算法的执行流程。得到的输出就是哈希值。</p><p>实际上这样的海绵结构不仅仅可以用于哈希函数中。由于输入输出长度可变的特性，当输入较长而输出较短的情况适用于HASH，MAC等场景；而当输入较短，输出较长的情况下适用于对称加密流密码的场景。在流密码的场景中，输入的时密钥与nonce值，输出的是密钥流。</p><h2 id="duplex-construction">Duplex construction</h2><p>事实上，海绵结构不仅仅可以一次吸收，一次挤出，它可以不断的重复吸收挤压的过程。<strong>keccak team</strong>提供了一种可以不断交替输入输出数据的结构，被称为双工结构（Duplex construction）。在这种结构允许我们不断的输入，输出，输入，输出数据。这种结构带来了一种好处：每一时刻的输出会受到之前输入与输出的影响。这样的属性可以实现相同操作的副本一致性（transcript consistency），也就意味着当不同的副本执行相同的操作，各个副本所维护的海绵结构可以保持一致性。</p><p><img src="duplex.png"></p><h2 id="summary">Summary</h2><p>这篇文章简单的介绍了keccak团队设计的海绵结构，以及它的工作方式。虽然keccak成为了最新的SHA-3算法标准，但是并不代表keccak只能当作哈希函数来使用。后续将会继续介绍基于keccak构造的密码学协议框架Strobe。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://strobe.sourceforge.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Strobe&lt;/a&gt;是一个面向物联网设计的密码学协议框架，目标是为了使加密协议更容易开发，部署，分析，并适用于微型物联网设备。在Strobe的设计中，仅使用了一个块函数Keccak-f来对消息进行加密和验证。&lt;/p&gt;
&lt;p&gt;Strobe利用了Keccak的海绵结构（Sponge Construction）来设计。这使得在Strobe的基础上，可以实现包括密码学哈希函数（Cryptographic hash function），消息认证码（Message authentication code）等机制；可以构建对称加密机制，数字签名机制（通过Schnorr Scheme），密钥交换机制（通过DH算法），以及TLS等类似的密码协议。&lt;/p&gt;
&lt;p&gt;在这里将会分析Strobe协议的组成以及其原理，以及如何在Strobe上构建密码协议。&lt;/p&gt;
&lt;p&gt;在分析Strobe协议之前，首先需要明确什么是海绵结构。&lt;/p&gt;
    
    </summary>
    
      <category term="cryptography" scheme="https://tiannian.github.io/categories/cryptography/"/>
    
    
      <category term="cryptography" scheme="https://tiannian.github.io/tags/cryptography/"/>
    
      <category term="strobe protocol framework" scheme="https://tiannian.github.io/tags/strobe-protocol-framework/"/>
    
      <category term="keccak" scheme="https://tiannian.github.io/tags/keccak/"/>
    
      <category term="SHA3" scheme="https://tiannian.github.io/tags/SHA3/"/>
    
  </entry>
  
  <entry>
    <title>数字签名机制 - ED25519</title>
    <link href="https://tiannian.github.io/2018/12/28/cryptography/ed25519/"/>
    <id>https://tiannian.github.io/2018/12/28/cryptography/ed25519/</id>
    <published>2018-12-28T02:35:12.000Z</published>
    <updated>2019-02-13T13:11:40.563Z</updated>
    
    <content type="html"><![CDATA[<p>ED25519是一种EdDSA算法，是一种在扭曲爱德华兹曲线（Twisted Edwards curves）上使用Schnorr机制来实现的一种数字签名机制。它具有速度快，密钥较短，安全性高等优点。</p><a id="more"></a><ol type="1"><li><a href="https://tiannian.github.io/2018/12/27/Schnorr-Scheme/">数字签名机制 - Schnorr Scheme</a></li><li><a href="https://tiannian.github.io/2018/12/28/ed25519/">数字签名机制- ED25519</a></li></ol><blockquote><p>本文中所有出现的变量，小写字母表示标量，即一个数字，在这里指整数；大写字母表示离散对数问题中的参数，例如：椭圆曲线中的点。</p></blockquote><p>椭圆曲线密码学（ECC）是基于离散对数问题中的椭圆曲线而设计的。现行的ECC算法多用于替代RSA算法，以提升原始算法的安全性与性能。相比较RSA，ECC的性能较高，密钥长度较短，然而实现难度较大。在ECC算法基础上构建的数字签名算法被称为ECDSA算法，经过NIST批准的曲线有多条，例如secp256r1，secp256k1等。但现有的ECC算法中的曲线被指存在后门。</p><p>EdDSA从某种意义上来说也属于椭圆曲线密码学，不同的是它采用扭曲爱德华兹曲线作为椭圆曲线，同时采用的签名机制也不同于ECDSA算法。EdDSA的重要实现ED25519是Daniel J. Bernstein等人设计的EdDSA算法，采用的曲线参数完全公开，并说明了参数选取的意义，保证曲线中并未内置后门。同时ED25519采用Schnorr机制作为签名的构建方式，使得签名与验证的性能得到了巨大的提升。</p><h2 id="ed25519算法">ED25519算法</h2><p>在现有的方案ED25519种，采用了将参数<span class="math inline">\(R\)</span>，公钥 <span class="math inline">\(Y\)</span>，与消息体 <span class="math inline">\(M\)</span>进行哈希作为随机数 <span class="math inline">\(r_2\)</span>。具体的ED25519公私钥生成与签名验证的方式如下：</p><h4 id="公私钥生成">公私钥生成</h4><p>当前根据ED25519协议中密钥长度 <span class="math inline">\(b\)</span>，被选择为<span class="math inline">\(256\)</span>；生成元为 <span class="math inline">\(G\)</span> ；哈希函数 <span class="math inline">\(H()\)</span>为SHA512；<span class="math inline">\(M\)</span>是被签名的信息；<span class="math inline">\(l\)</span> 是一个质数，满足<span class="math inline">\(lG = 0\)</span>。</p><ol type="1"><li>随机选择一个长度为 <span class="math inline">\(b\)</span> 为的二进制数作为私钥 <span class="math inline">\(a\)</span>。</li><li>对 <span class="math inline">\(a\)</span> 的进行哈希，产生一个长度为 <span class="math inline">\(2b\)</span> 的值为 <span class="math inline">\(h = H(a)\)</span>，其中 <span class="math inline">\(h_0 \ldots h_{b-1}\)</span> 为<span class="math inline">\(x\)</span>，用于产生公钥 ，<span class="math inline">\(h_b \dots h_{2b-1}\)</span> 为随机数 <span class="math inline">\(k\)</span> 。</li><li>将 <span class="math inline">\(x_0, x_1, x_2​\)</span>置<span class="math inline">\(0​\)</span>，<span class="math inline">\(x_{b-1}​\)</span>置0，<span class="math inline">\(x_{b-2}​\)</span>置1。</li><li>计算公钥 <span class="math inline">\(Y = xG\)</span>。</li></ol><p>其中 <span class="math inline">\(a\)</span> 为私钥，<span class="math inline">\(Y\)</span>为公钥。</p><h4 id="签名流程">签名流程</h4><p>进行签名时，需要私钥 <span class="math inline">\(a\)</span>，执行公私钥生成算法，得到公钥 <span class="math inline">\(Y\)</span>，随机数 <span class="math inline">\(k\)</span>。</p><ol type="1"><li>计算随机数 <span class="math inline">\(r = H(k, M)\)</span>。</li><li>计算随机点<span class="math inline">\(R = rG\)</span>。</li><li>计算签名<span class="math inline">\(s = (r + H(R,Y,M)x ) \bmod l\)</span>。</li></ol><p>其中得到的<span class="math inline">\((R,s)\)</span>便是得到的数字签名。</p><p>其中 <span class="math inline">\(s\)</span> 相当于前文所述Schnorr签名方案中的 <span class="math inline">\(s\)</span> ，<span class="math inline">\(r\)</span> 相当于 <span class="math inline">\(r_1\)</span> ，<span class="math inline">\(H(R,Y,M)\)</span>相当于<span class="math inline">\(r_2\)</span>。这里的哈希函数<span class="math inline">\(H()\)</span>便充当了随机数预言机。</p><h4 id="验证流程">验证流程</h4><p>进行验证时，验证者只需要知道公钥 <span class="math inline">\(Y\)</span>，签名<span class="math inline">\((R,s)\)</span>， 消息 <span class="math inline">\(M\)</span> 即可验证签名过程是否正确。</p><ul><li>验证<span class="math inline">\(sG = R + H(R,Y,M)Y\)</span>是否成立，即可验证签名是否正确。</li></ul><p>其中 <span class="math inline">\(s\)</span> 相当于前文所述Schnorr签名方案中验证公式中的 <span class="math inline">\(s\)</span> ，<span class="math inline">\(G\)</span> 为生成元，<span class="math inline">\(H(R,Y,M)\)</span>为 <span class="math inline">\(r_2\)</span> ，其余部分一一对应。</p><h2 id="安全考量">安全考量</h2><p>在ED25519的算法设计中，通过使用密码学哈希函数来代替伪随机数发生器，避免了签名算法的使用者因为采用的随机数生成器不够随机化而产生的安全问题。ED25519的实现除去私钥的生成之外，签名过程已经完全脱离对随机数发生器的依赖，避免了因为随机化问题而导致密钥的泄露与安全性问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ED25519是一种EdDSA算法，是一种在扭曲爱德华兹曲线（Twisted Edwards curves）上使用Schnorr机制来实现的一种数字签名机制。它具有速度快，密钥较短，安全性高等优点。&lt;/p&gt;
    
    </summary>
    
      <category term="cryptography" scheme="https://tiannian.github.io/categories/cryptography/"/>
    
    
      <category term="cryptography" scheme="https://tiannian.github.io/tags/cryptography/"/>
    
      <category term="schnorr scheme" scheme="https://tiannian.github.io/tags/schnorr-scheme/"/>
    
      <category term="digital signature" scheme="https://tiannian.github.io/tags/digital-signature/"/>
    
      <category term="ED25519" scheme="https://tiannian.github.io/tags/ED25519/"/>
    
      <category term="EdDSA" scheme="https://tiannian.github.io/tags/EdDSA/"/>
    
  </entry>
  
  <entry>
    <title>数字签名机制 - Schnorr Scheme</title>
    <link href="https://tiannian.github.io/2018/12/27/cryptography/Schnorr-Scheme/"/>
    <id>https://tiannian.github.io/2018/12/27/cryptography/Schnorr-Scheme/</id>
    <published>2018-12-27T07:25:46.000Z</published>
    <updated>2019-02-13T13:11:40.535Z</updated>
    
    <content type="html"><![CDATA[<p>Schnorr机制是一种基于离散对数难题的知识证明机制，由德国数学家和密码学家Claus-Peter Schnorr在1990年提出。这种知识证明机制具有实现简单，验证速度较快等优点。最开始是为Smart Card这样的资源受限设备而设计。</p><p>经过这些年的发展，在原始的Schnorr机制上实现了多种多样的改进与功能，实现了高性能的数字签名，以及包括环签名，门限签名等复杂签名机制。</p><p>在这里参考Schnorr的论文与其他的参考资料，分析Schnorr机制的原始机制与实现。并分析现在主流的EdDSA的实现ED25519，以及如何在Schnorr机制上建立的复杂签名机制。</p><a id="more"></a><ol type="1"><li><a href="https://tiannian.github.io/2018/12/27/Schnorr-Scheme/">数字签名机制 - Schnorr Scheme</a></li><li><a href="https://tiannian.github.io/2018/12/28/ed25519/">数字签名机制- ED25519</a></li></ol><blockquote><p>本文中所有出现的变量，小写字母表示标量，即一个数字，在这里指整数；大写字母表示离散对数问题中的参数，例如：椭圆曲线中的点。</p></blockquote><h3 id="original-schnorr-scheme">Original Schnorr Scheme</h3><p>原始的Schnorr机制是一个交互式的机制。允许在任何拥有相同生成元（指在离散对数问题中）的协议参与者双方，证明某一方拥有私钥 <span class="math inline">\(x\)</span> 而不需要直接交换它。其中双方都拥有的生成元设为 <span class="math inline">\(G\)</span> ，证明者拥有私钥 <span class="math inline">\(x\)</span> 。验证者从证明者处取得 <span class="math inline">\(Y\)</span> ，其中 <span class="math inline">\(Y = xG\)</span>，<span class="math inline">\(Y\)</span> 即公钥。</p><p>Original Schnorr Signature的协议流程如下：</p><ol type="1"><li>证明者随机选择一个标量 <span class="math inline">\(r_1\)</span>，然后计算出 <span class="math inline">\(R = r_1G\)</span>。并将 <span class="math inline">\(R\)</span> 发送至验证者。</li><li>验证者回应一个随机的标量 <span class="math inline">\(r_2\)</span>。</li><li>证明者回应一个标量<span class="math inline">\(s\)</span>，通过公式 <span class="math inline">\(s = r_1 + r_2x\)</span> 计算。</li></ol><p>因为离散对数问题是困难的，因此验证者不会知道 <span class="math inline">\(x, r_1\)</span>的值，验证者仅知道由 <span class="math inline">\(x, r_1\)</span>计算得到的 <span class="math inline">\(Y, R\)</span>。但是验证者可以通过以下计算来验证<span class="math inline">\(s\)</span>是正确的：</p><ul><li>由于<span class="math inline">\(s = r_1 + r_2x\)</span>，等式两边同时添加相同的生成元可得 <span class="math inline">\(sG = r_1G + r_2xG\)</span>。</li><li>由于<span class="math inline">\(R = r_1G\)</span>，<span class="math inline">\(Y = xG\)</span>，可以化简得到 <span class="math inline">\(sG = R + r_2Y\)</span>。</li></ul><p>其中 <span class="math inline">\(G\)</span> 是生成元，双方都可知，<span class="math inline">\(R, Y, s, r_2\)</span> 验证者都知道，所以验证者可以轻松验证化简过的公式。</p><p>这个过程是零知识的，因为验证者并不能得到私钥 <span class="math inline">\(x\)</span> 的值，却可以通过计算与通讯的方式验证证明者确实拥有私钥 <span class="math inline">\(x\)</span>。</p><h3 id="problem-of-original-schnorr-scheme">Problem of Original Schnorr Scheme</h3><p>然而这样交互式的过程，会导致验证者通过"fork"的方式获得私钥 <span class="math inline">\(x\)</span>。验证者只需要简单的提供两个不同的随机值 <span class="math inline">\(r_2^1, r_2^2\)</span>，并要求证明者计算 <span class="math inline">\(s_1 = r_1 + r_2^1x, s_2 = r_1 + r_2^2x\)</span>，即可计算出<span class="math inline">\(x = (s_1 - s_2)/(r_2^1 - r_2^2)\)</span>。这样一来，这个过程便无法公开的验证，因为一旦两个验证者相互串通，交换自己得到的值，便可以推出私钥<span class="math inline">\(x\)</span>。</p><p>为了解决这个问题，后续将会通过对现有的协议进行Fiat–Shamir变换，使用Random oracles改造这个算法来使Schnorr原始的Schnorr Scheme变成可公开验证的非交互式算法。</p><h3 id="fiatshamir-and-random-oracles">Fiat–Shamir and Random oracles</h3><p>上述原始Schnorr Scheme中存在的私钥泄露问题使得算法无法在公开的环境下使用。通过将原始的交互式协议转变为非交互式协议可以解决这个问题。</p><p>Fiat–Shamir变换是一种利用交互式零知识证明方案创建数字签名的方式。根据Fiat–Shamir变换，我们可以将原始方案中的证明者采用随机数预言机（Random oracle）来代替，利用这样的方式构造数字签名。</p><p>随机数预言机，即随机数函数，是一种针对任意输入得到的输出之间是项目独立切均匀分布的函数。理想的随机数预言机并不存在，在实现中，经常采用密码学哈希函数作为随机数预言机。</p><p>原本的设计中，Schnorr签名是一种交互式协议，需要一个实际存在的验证者与参与者，而根据Fiat-Shamir转换，可以将具体的验证者采用随机数预言机来代替。将验证者替换为随机数预言机后，外部的验证者便无法通过交换 <span class="math inline">\(r_2\)</span>来推出私钥 <span class="math inline">\(x\)</span> ，原本的 <span class="math inline">\(r_2\)</span> 采用随机数预言机产生的随机数来表示。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Schnorr机制是一种基于离散对数难题的知识证明机制，由德国数学家和密码学家Claus-Peter Schnorr在1990年提出。这种知识证明机制具有实现简单，验证速度较快等优点。最开始是为Smart Card这样的资源受限设备而设计。&lt;/p&gt;
&lt;p&gt;经过这些年的发展，在原始的Schnorr机制上实现了多种多样的改进与功能，实现了高性能的数字签名，以及包括环签名，门限签名等复杂签名机制。&lt;/p&gt;
&lt;p&gt;在这里参考Schnorr的论文与其他的参考资料，分析Schnorr机制的原始机制与实现。并分析现在主流的EdDSA的实现ED25519，以及如何在Schnorr机制上建立的复杂签名机制。&lt;/p&gt;
    
    </summary>
    
      <category term="cryptography" scheme="https://tiannian.github.io/categories/cryptography/"/>
    
    
      <category term="cryptography" scheme="https://tiannian.github.io/tags/cryptography/"/>
    
      <category term="schnorr scheme" scheme="https://tiannian.github.io/tags/schnorr-scheme/"/>
    
      <category term="digital signature" scheme="https://tiannian.github.io/tags/digital-signature/"/>
    
      <category term="ED25519" scheme="https://tiannian.github.io/tags/ED25519/"/>
    
      <category term="EdDSA" scheme="https://tiannian.github.io/tags/EdDSA/"/>
    
  </entry>
  
</feed>
