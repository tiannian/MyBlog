<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Schnorr Scheme]]></title>
    <url>%2F2018%2F12%2F27%2FSchnorr-Scheme%2F</url>
    <content type="text"><![CDATA[Schnorr签名机制是一种基于离散对数难题的数字签名机制，由德国数学家和密码学家Claus-Peter Schnorr在1990年提出。这种数字签名机制具有实现简单，签名验证速度较快等优点。最开始是为Smart Card这样的资源受限设备而设计。 经过这些年的发展，在原始的Schnorr机制上实现了多种多样的改进与功能，包括环签名，门限签名等机制。 在这里参考Schnorr的论文与其他的参考资料，解析Schnorr签名的原始机制与实现。最终会解析现在主流的EdDSA的实现ED25519与种对Schnorr签名的应用。 本文中所有出现的变量，小写字母表示标量，即一个数字，在这里指整数；大写字母表示离散对数问题中的参数，例如：椭圆曲线中的点。 Original Schnorr Scheme 原始的Schnorr签名是一个交互式的签名机制。允许在任何拥有相同生成元（指在离散对数问题中）的协议参与者双方，证明某一方拥有私钥 \(x\) 而不需要直接交换它。其中双方都拥有的生成元设为 \(G\) ，证明者拥有私钥 \(x\) 。验证者从证明者处取得 \(Y\) ，其中 \(Y = xG\)，\(Y\) 即公钥。 Original Schnorr Signature的协议流程如下： 证明者随机选择一个标量 \(r_1\)，然后计算出 \(R = r_1G\)。并将 \(R\) 发送至验证者。 验证者回应一个随机的标量 \(r_2\)。 证明者回应一个标量\(s\)，通过公式 \(s = r_1 + r_2x\) 计算。 因为离散对数问题是困难的，因此验证者不会知道 \(x, r_1\)的值，验证者仅知道由 \(x, r_1\)计算得到的 \(Y, R\)。但是验证者可以通过以下计算来验证\(s\)是正确的： 由于\(s = r_1 + r_2x\)，等式两边同时添加相同的生成元可得 \(sG = r_1G + r_2xG\)。 由于\(R = r_1G\)，\(Y = xG\)，可以化简得到 \(sG = R + r_2Y\)。 其中 \(G\) 是生成元，双方都可知，\(R, Y, s, r_2\) 验证者都知道，所以验证者可以轻松验证化简过的公式。 这个过程是零知识的，因为验证者并不能得到私钥 \(x\) 的值，却可以通过计算与通讯的方式验证证明者确实拥有私钥 \(x\)。 Problem of Original Schnorr Scheme 然而这样交互式的过程，会导致验证者通过"fork"的方式获得私钥 \(x\)。验证者只需要简单的提供两个不同的随机值 \(r_2^1, r_2^2\)，并要求证明者计算 \(s_1 = r_1 + r_2^1x, s_2 = r_1 + r_2^2x\)，即可计算出\(x = (s_1 - s_2)/(r_2^1 - r_2^2)\)。这样一来，这个过程便无法公开的验证，因为一旦两个验证者相互串通，交换自己得到的值，便可以推出私钥\(x\)。 为了解决这个问题，后续将会通过对现有的协议进行Fiat–Shamir变换，使用Random oracles改造这个算法来使Schnorr原始的Schnorr Scheme变成可公开验证的非交互式算法。]]></content>
      <tags>
        <tag>cryptography</tag>
        <tag>schnorr scheme</tag>
        <tag>digital signature</tag>
        <tag>ED25519</tag>
        <tag>EdDSA</tag>
      </tags>
  </entry>
</search>
